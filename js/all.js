// Generated by CoffeeScript 1.6.3
(function() {
  var DelayedOp, DelayedSyncAnimation, Dropbox, DropboxClient, DropboxOauth, DropboxXhr, DropboxXhrCanSendForms, DropboxXhrIeMode, DropboxXhrRequest, OneOp, REALTIME_MIMETYPE, Set, add32, arrayToBase64, atob, atobNibble, b64chars, b64tab, base64Digits, base64HmacSha1, base64Sha1, btoa, btoaNibble, btou, buffer, cb_btou, cb_decode, cb_encode, cb_utob, crypto, decode, dropboxEncodeKey, encode, encodeURI, exports, fromCharCode, global, handleErrors, hmacSha1, mixpanel_token, noEnum, re_btou, re_utob, rotateLeft32, sha1, stringToArray, utob, version, _base64Digits, _decode, _encode,
    __hasProp = {}.hasOwnProperty,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  (function() {
    var Nimbus, headID, newScript;
    if (window.Nimbus == null) {
      window.Nimbus = {};
    }
    Nimbus = window.Nimbus;
    window.handle_initialization = null;
    Nimbus.loaded = false;
    window.handleClientLoad = function() {
      console.log("loaded CALLED");
      Nimbus.loaded = true;
      if (Nimbus.gdrive_initialized) {
        return Nimbus.Auth.initialize();
      }
    };
    headID = document.getElementsByTagName("head")[0];
    newScript = document.createElement("script");
    newScript.type = "text/javascript";
    newScript.src = "https://apis.google.com/js/client.js?onload=handleClientLoad";
    return headID.appendChild(newScript);
  })();

  Dropbox = (function() {
    function Dropbox(options) {
      this.client = new DropboxClient(options);
    }

    return Dropbox;

  })();

  Dropbox.ApiError = (function() {
    function ApiError(xhr, method, url) {
      var e, text;
      this.method = method;
      this.url = url;
      this.status = xhr.status;
      if (xhr.responseType) {
        text = xhr.response || xhr.responseText;
      } else {
        text = xhr.responseText;
      }
      if (text) {
        try {
          this.responseText = text.toString();
          this.response = JSON.parse(text);
        } catch (_error) {
          e = _error;
          this.response = null;
        }
      } else {
        this.responseText = '(no response)';
        this.response = null;
      }
    }

    ApiError.prototype.toString = function() {
      return "Dropbox API error " + this.status + " from " + this.method + " " + this.url + " :: " + this.responseText;
    };

    ApiError.prototype.inspect = function() {
      return this.toString();
    };

    return ApiError;

  })();

  if (typeof window !== "undefined" && window !== null) {
    if (window.atob && window.btoa) {
      atob = function(string) {
        return window.atob(string);
      };
      btoa = function(base64) {
        return window.btoa(base64);
      };
    } else {
      base64Digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      btoaNibble = function(accumulator, bytes, result) {
        var i, limit;
        limit = 3 - bytes;
        accumulator <<= limit * 8;
        i = 3;
        while (i >= limit) {
          result.push(base64Digits.charAt((accumulator >> (i * 6)) & 0x3F));
          i -= 1;
        }
        i = bytes;
        while (i < 3) {
          result.push('=');
          i += 1;
        }
        return null;
      };
      atobNibble = function(accumulator, digits, result) {
        var i, limit;
        limit = 4 - digits;
        accumulator <<= limit * 6;
        i = 2;
        while (i >= limit) {
          result.push(String.fromCharCode((accumulator >> (8 * i)) & 0xFF));
          i -= 1;
        }
        return null;
      };
      btoa = function(string) {
        var accumulator, bytes, i, result, _i, _ref;
        result = [];
        accumulator = 0;
        bytes = 0;
        for (i = _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          accumulator = (accumulator << 8) | string.charCodeAt(i);
          bytes += 1;
          if (bytes === 3) {
            btoaNibble(accumulator, bytes, result);
            accumulator = bytes = 0;
          }
        }
        if (bytes > 0) {
          btoaNibble(accumulator, bytes, result);
        }
        return result.join('');
      };
      atob = function(base64) {
        var accumulator, digit, digits, i, result, _i, _ref;
        result = [];
        accumulator = 0;
        digits = 0;
        for (i = _i = 0, _ref = base64.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          digit = base64.charAt(i);
          if (digit === '=') {
            break;
          }
          accumulator = (accumulator << 6) | base64Digits.indexOf(digit);
          digits += 1;
          if (digits === 4) {
            atobNibble(accumulator, digits, result);
            accumulator = digits = 0;
          }
        }
        if (digits > 0) {
          atobNibble(accumulator, digits, result);
        }
        return result.join('');
      };
    }
  } else {
    atob = function(arg) {
      var buffer, i;
      buffer = new Buffer(arg, 'base64');
      return ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = buffer.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(String.fromCharCode(buffer[i]));
        }
        return _results;
      })()).join('');
    };
    btoa = function(arg) {
      var buffer, i;
      buffer = new Buffer((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = arg.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(arg.charCodeAt(i));
        }
        return _results;
      })());
      return buffer.toString('base64');
    };
  }

  Dropbox.Client = (function() {
    function Client(options) {
      this.sandbox = options.sandbox || false;
      this.apiServer = options.server || this.defaultApiServer();
      this.authServer = options.authServer || this.defaultAuthServer();
      this.fileServer = options.fileServer || this.defaultFileServer();
      this.oauth = new DropboxOauth(options);
      this.uid = null;
      this.authState = null;
      this.authError = null;
      this._credentials = null;
      this.setCredentials(options);
      this.setupUrls();
    }

    Client.prototype.authDriver = function(driver) {
      this.driver = driver;
      return this;
    };

    Client.prototype.dropboxUid = function() {
      return this.uid;
    };

    Client.prototype.credentials = function() {
      if (!this._credentials) {
        this.computeCredentials();
      }
      return this._credentials;
    };

    Client.prototype.authenticate = function(callback) {
      var oldAuthState, _fsmStep,
        _this = this;
      oldAuthState = null;
      _fsmStep = function() {
        var authUrl;
        if (oldAuthState !== _this.authState) {
          oldAuthState = _this.authState;
          if (_this.driver.onAuthStateChange) {
            return _this.driver.onAuthStateChange(_this, _fsmStep);
          }
        }
        switch (_this.authState) {
          case DropboxClient.RESET:
            return _this.requestToken(function(error, data) {
              var token, tokenSecret;
              if (error) {
                _this.authError = error;
                _this.authState = DropboxClient.ERROR;
              } else {
                token = data.oauth_token;
                tokenSecret = data.oauth_token_secret;
                _this.oauth.setToken(token, tokenSecret);
                _this.authState = DropboxClient.REQUEST;
              }
              _this._credentials = null;
              return _fsmStep();
            });
          case DropboxClient.REQUEST:
            authUrl = _this.authorizeUrl(_this.oauth.token);
            return _this.driver.doAuthorize(authUrl, _this.oauth.token, _this.oauth.tokenSecret, function() {
              _this.authState = DropboxClient.AUTHORIZED;
              _this._credentials = null;
              return _fsmStep();
            });
          case DropboxClient.AUTHORIZED:
            return _this.getAccessToken(function(error, data) {
              if (error) {
                _this.authError = error;
                _this.authState = DropboxClient.ERROR;
              } else {
                _this.oauth.setToken(data.oauth_token, data.oauth_token_secret);
                _this.uid = data.uid;
                _this.authState = DropboxClient.DONE;
              }
              _this._credentials = null;
              return _fsmStep();
            });
          case DropboxClient.DONE:
            return callback(null, _this);
          case Dropbox.SIGNED_OFF:
            _this.reset();
            return _fsmStep();
          case DropboxClient.ERROR:
            return callback(_this.authError);
        }
      };
      _fsmStep();
      return this;
    };

    Client.prototype.signOut = function(callback) {
      var params, url,
        _this = this;
      url = this.urls.signOut;
      params = this.oauth.addAuthParams('POST', url, {});
      return Dropbox.Xhr.request('POST', url, params, null, function(error) {
        if (error) {
          return callback(error);
        }
        _this.reset();
        _this.authState = DropboxClient.SIGNED_OFF;
        if (_this.driver.onAuthStateChange) {
          return _this.driver.onAuthStateChange(_this, function() {
            return callback(error);
          });
        } else {
          return callback(error);
        }
      });
    };

    Client.prototype.signOff = function(callback) {
      return this.signOut(callback);
    };

    Client.prototype.getUserInfo = function(callback) {
      var params, url;
      url = this.urls.accountInfo;
      params = this.oauth.addAuthParams('GET', url, {});
      return Dropbox.Xhr.request('GET', url, params, null, function(error, userData) {
        return callback(error, Dropbox.UserInfo.parse(userData), userData);
      });
    };

    Client.prototype.readFile = function(path, options, callback) {
      var params, responseType, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = "" + this.urls.getFile + "/" + (this.urlEncodePath(path));
      params = {};
      responseType = null;
      if (options) {
        if (options.versionTag) {
          params.rev = options.versionTag;
        } else if (options.rev) {
          params.rev = options.rev;
        }
        if (options.blob) {
          responseType = 'blob';
        }
        if (options.binary) {
          responseType = 'b';
        }
      }
      this.oauth.addAuthParams('GET', url, params);
      return Dropbox.Xhr.request2('GET', url, params, null, null, responseType, function(error, data, metadata) {
        return callback(error, data, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.writeFile = function(path, data, options, callback) {
      var useForm;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      useForm = Dropbox.Xhr.canSendForms && typeof data === 'object';
      if (useForm) {
        return this.writeFileUsingForm(path, data, options, callback);
      } else {
        return this.writeFileUsingPut(path, data, options, callback);
      }
    };

    Client.prototype.writeFileUsingForm = function(path, data, options, callback) {
      var fileField, fileName, params, slashIndex, url;
      slashIndex = path.lastIndexOf('/');
      if (slashIndex === -1) {
        fileName = path;
        path = '';
      } else {
        fileName = path.substring(slashIndex);
        path = path.substring(0, slashIndex);
      }
      url = "" + this.urls.postFile + "/" + (this.urlEncodePath(path));
      params = {
        file: fileName
      };
      if (options) {
        if (options.noOverwrite) {
          params.overwrite = 'false';
        }
        if (options.lastVersionTag) {
          params.parent_rev = options.lastVersionTag;
        } else if (options.parentRev || options.parent_rev) {
          params.parent_rev = options.parentRev || options.parent_rev;
        }
      }
      this.oauth.addAuthParams('POST', url, params);
      delete params.file;
      fileField = {
        name: 'file',
        value: data,
        fileName: fileName,
        contentType: 'application/octet-stream'
      };
      return Dropbox.Xhr.multipartRequest(url, fileField, params, null, function(error, metadata) {
        return callback(error, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.writeFileUsingPut = function(path, data, options, callback) {
      var params, url;
      url = "" + this.urls.putFile + "/" + (this.urlEncodePath(path));
      params = {};
      if (options) {
        if (options.noOverwrite) {
          params.overwrite = 'false';
        }
        if (options.lastVersionTag) {
          params.parent_rev = options.lastVersionTag;
        } else if (options.parentRev || options.parent_rev) {
          params.parent_rev = options.parentRev || options.parent_rev;
        }
      }
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request2('POST', url, params, null, data, null, function(error, metadata) {
        return callback(error, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.stat = function(path, options, callback) {
      var params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = "" + this.urls.metadata + "/" + (this.urlEncodePath(path));
      params = {};
      if (options) {
        if (options.version != null) {
          params.rev = options.version;
        }
        if (options.removed || options.deleted) {
          params.include_deleted = 'true';
        }
        if (options.readDir) {
          params.list = 'true';
          if (options.readDir !== true) {
            params.file_limit = options.readDir.toString();
          }
        }
        if (options.cacheHash) {
          params.hash = options.cacheHash;
        }
      }
      params.include_deleted || (params.include_deleted = 'false');
      params.list || (params.list = 'false');
      this.oauth.addAuthParams('GET', url, params);
      return Dropbox.Xhr.request('GET', url, params, null, function(error, metadata) {
        var entries, entry, stat;
        stat = Dropbox.Stat.parse(metadata);
        if (metadata != null ? metadata.contents : void 0) {
          entries = (function() {
            var _i, _len, _ref, _results;
            _ref = metadata.contents;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              entry = _ref[_i];
              _results.push(Dropbox.Stat.parse(entry));
            }
            return _results;
          })();
        } else {
          entries = void 0;
        }
        return callback(error, stat, entries);
      });
    };

    Client.prototype.readdir = function(path, options, callback) {
      var statOptions;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      statOptions = {
        readDir: true
      };
      if (options) {
        if (options.limit != null) {
          statOptions.readDir = options.limit;
        }
        if (options.versionTag) {
          statOptions.versionTag = options.versionTag;
        }
      }
      return this.stat(path, statOptions, function(error, stat, entry_stats) {
        var entries, entry_stat;
        if (entry_stats) {
          entries = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = entry_stats.length; _i < _len; _i++) {
              entry_stat = entry_stats[_i];
              _results.push(entry_stat.name);
            }
            return _results;
          })();
        } else {
          entries = null;
        }
        return callback(error, entries, stat, entry_stats);
      });
    };

    Client.prototype.metadata = function(path, options, callback) {
      return this.stat(path, options, callback);
    };

    Client.prototype.makeUrl = function(path, options, callback) {
      var isDirect, params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      path = this.urlEncodePath(path);
      if (options && options.download) {
        isDirect = true;
        url = "" + this.urls.media + "/" + path;
      } else {
        isDirect = false;
        url = "" + this.urls.shares + "/" + path;
      }
      if (options && (options['long'] || options.longUrl)) {
        params = {
          short_url: 'false'
        };
      } else {
        params = {};
      }
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request('POST', url, params, null, function(error, urlData) {
        return callback(error, Dropbox.PublicUrl.parse(urlData, isDirect));
      });
    };

    Client.prototype.history = function(path, options, callback) {
      var params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = "" + this.urls.revisions + "/" + (this.urlEncodePath(path));
      params = {};
      if (options && (options.limit != null)) {
        params.rev_limit = options.limit;
      }
      this.oauth.addAuthParams('GET', url, params);
      return Dropbox.Xhr.request('GET', url, params, null, function(error, versions) {
        var metadata, stats;
        if (versions) {
          stats = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = versions.length; _i < _len; _i++) {
              metadata = versions[_i];
              _results.push(Dropbox.Stat.parse(metadata));
            }
            return _results;
          })();
        } else {
          stats = void 0;
        }
        return callback(error, stats);
      });
    };

    Client.prototype.revisions = function(path, options, callback) {
      return this.history(path, options, callback);
    };

    Client.prototype.thumbnailUrl = function(path, options) {
      var params, url;
      url = "" + this.urls.thumbnails + "/" + (this.urlEncodePath(path));
      params = {};
      if (options) {
        if (options.format) {
          params.format = options.format;
        } else if (options.png) {
          params.format = 'png';
        }
        if (options.size) {
          params.size = options.size;
        }
      }
      this.oauth.addAuthParams('GET', url, params);
      return "" + url + "?" + (Dropbox.Xhr.urlEncode(params));
    };

    Client.prototype.readThumbnail = function(path, options, callback) {
      var responseType, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = this.thumbnailUrl(path, options);
      responseType = 'b';
      if (options) {
        if (options.blob) {
          responseType = 'blob';
        }
      }
      return Dropbox.Xhr.request2('GET', url, {}, null, null, responseType, function(error, data, metadata) {
        return callback(error, data, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.revertFile = function(path, versionTag, callback) {
      var params, url;
      url = "" + this.urls.restore + "/" + (this.urlEncodePath(path));
      params = {
        rev: versionTag
      };
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.restore = function(path, versionTag, callback) {
      return this.revertFile(path, versionTag, callback);
    };

    Client.prototype.findByName = function(path, namePattern, options, callback) {
      var params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = "" + this.urls.search + "/" + (this.urlEncodePath(path));
      params = {
        query: namePattern
      };
      if (options) {
        if (options.limit != null) {
          params.file_limit = options.limit;
        }
        if (options.removed || options.deleted) {
          params.include_deleted = true;
        }
      }
      this.oauth.addAuthParams('GET', url, params);
      return Dropbox.Xhr.request('GET', url, params, null, function(error, results) {
        var metadata, stats;
        if (results) {
          stats = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = results.length; _i < _len; _i++) {
              metadata = results[_i];
              _results.push(Dropbox.Stat.parse(metadata));
            }
            return _results;
          })();
        } else {
          stats = void 0;
        }
        return callback(error, stats);
      });
    };

    Client.prototype.search = function(path, namePattern, options, callback) {
      return this.findByName(path, namePattern, options, callback);
    };

    Client.prototype.makeCopyReference = function(path, callback) {
      var params, url;
      url = "" + this.urls.copyRef + "/" + (this.urlEncodePath(path));
      params = this.oauth.addAuthParams('GET', url, {});
      return Dropbox.Xhr.request('GET', url, params, null, function(error, refData) {
        return callback(error, Dropbox.CopyReference.parse(refData));
      });
    };

    Client.prototype.copyRef = function(path, callback) {
      return this.makeCopyReference(path, callback);
    };

    Client.prototype.pullChanges = function(cursor, callback) {
      var params, url;
      if ((!callback) && (typeof cursor === 'function')) {
        callback = cursor;
        cursor = null;
      }
      url = this.urls.delta;
      params = {};
      if (cursor) {
        if (cursor.cursorTag) {
          params = {
            cursor: cursor.cursorTag
          };
        } else {
          params = {
            cursor: cursor
          };
        }
      } else {
        params = {};
      }
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request('POST', url, params, null, function(error, deltaInfo) {
        return callback(error, Dropbox.PulledChanges.parse(deltaInfo));
      });
    };

    Client.prototype.delta = function(cursor, callback) {
      return this.pullChanges(cursor, callback);
    };

    Client.prototype.mkdir = function(path, callback) {
      var params, url;
      url = this.urls.fileopsCreateFolder;
      params = {
        root: this.fileRoot,
        path: this.normalizePath(path)
      };
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.remove = function(path, callback) {
      var params, url;
      url = this.urls.fileopsDelete;
      params = {
        root: this.fileRoot,
        path: this.normalizePath(path)
      };
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.unlink = function(path, callback) {
      return this.remove(path, callback);
    };

    Client.prototype["delete"] = function(path, callback) {
      return this.remove(path, callback);
    };

    Client.prototype.copy = function(from, toPath, callback) {
      var options, params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      params = {
        root: this.fileRoot,
        to_path: this.normalizePath(toPath)
      };
      if (from instanceof Dropbox.CopyReference) {
        params.from_copy_ref = from.tag;
      } else {
        params.from_path = this.normalizePath(from);
      }
      url = this.urls.fileopsCopy;
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.move = function(fromPath, toPath, callback) {
      var options, params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      fromPath = this.normalizePath(fromPath);
      toPath = this.normalizePath(toPath);
      url = this.urls.fileopsMove;
      params = {
        root: this.fileRoot,
        from_path: fromPath,
        to_path: toPath
      };
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.reset = function() {
      this.uid = null;
      this.oauth.setToken(null, '');
      this.authState = DropboxClient.RESET;
      this.authError = null;
      this._credentials = null;
      return this;
    };

    Client.prototype.setCredentials = function(credentials) {
      this.oauth.reset(credentials);
      this.uid = credentials.uid || null;
      if (credentials.authState) {
        this.authState = credentials.authState;
      } else {
        if (credentials.token) {
          this.authState = DropboxClient.DONE;
        } else {
          this.authState = DropboxClient.RESET;
        }
      }
      this.authError = null;
      this._credentials = null;
      return this;
    };

    Client.prototype.appHash = function() {
      return this.oauth.appHash();
    };

    Client.prototype.setupUrls = function() {
      this.fileRoot = this.sandbox ? 'sandbox' : 'dropbox';
      return this.urls = {
        requestToken: "" + this.apiServer + "/1/oauth/request_token",
        authorize: "" + this.authServer + "/1/oauth/authorize",
        accessToken: "" + this.apiServer + "/1/oauth/access_token",
        signOut: "" + this.apiServer + "/1/unlink_access_token",
        accountInfo: "" + this.apiServer + "/1/account/info",
        getFile: "" + this.fileServer + "/1/files/" + this.fileRoot,
        postFile: "" + this.fileServer + "/1/files/" + this.fileRoot,
        putFile: "" + this.fileServer + "/1/files_put/" + this.fileRoot,
        metadata: "" + this.apiServer + "/1/metadata/" + this.fileRoot,
        delta: "" + this.apiServer + "/1/delta",
        revisions: "" + this.apiServer + "/1/revisions/" + this.fileRoot,
        restore: "" + this.apiServer + "/1/restore/" + this.fileRoot,
        search: "" + this.apiServer + "/1/search/" + this.fileRoot,
        shares: "" + this.apiServer + "/1/shares/" + this.fileRoot,
        media: "" + this.apiServer + "/1/media/" + this.fileRoot,
        copyRef: "" + this.apiServer + "/1/copy_ref/" + this.fileRoot,
        thumbnails: "" + this.fileServer + "/1/thumbnails/" + this.fileRoot,
        fileopsCopy: "" + this.apiServer + "/1/fileops/copy",
        fileopsCreateFolder: "" + this.apiServer + "/1/fileops/create_folder",
        fileopsDelete: "" + this.apiServer + "/1/fileops/delete",
        fileopsMove: "" + this.apiServer + "/1/fileops/move"
      };
    };

    Client.ERROR = 0;

    Client.RESET = 1;

    Client.REQUEST = 2;

    Client.AUTHORIZED = 3;

    Client.DONE = 4;

    Client.SIGNED_OFF = 5;

    Client.prototype.urlEncodePath = function(path) {
      return Dropbox.Xhr.urlEncodeValue(this.normalizePath(path)).replace(/%2F/gi, '/');
    };

    Client.prototype.normalizePath = function(path) {
      var i;
      if (path.substring(0, 1) === '/') {
        i = 1;
        while (path.substring(i, i + 1) === '/') {
          i += 1;
        }
        return path.substring(i);
      } else {
        return path;
      }
    };

    Client.prototype.requestToken = function(callback) {
      var params;
      params = this.oauth.addAuthParams('POST', this.urls.requestToken, {});
      return Dropbox.Xhr.request('POST', this.urls.requestToken, params, null, callback);
    };

    Client.prototype.authorizeUrl = function(token) {
      var params;
      params = {
        oauth_token: token,
        oauth_callback: this.driver.url()
      };
      return ("" + this.urls.authorize + "?") + Dropbox.Xhr.urlEncode(params);
    };

    Client.prototype.getAccessToken = function(callback) {
      var params;
      params = this.oauth.addAuthParams('POST', this.urls.accessToken, {});
      return Dropbox.Xhr.request('POST', this.urls.accessToken, params, null, callback);
    };

    Client.prototype.defaultApiServer = function() {
      return 'https://api.dropbox.com';
    };

    Client.prototype.defaultAuthServer = function() {
      return this.apiServer.replace('api.', 'www.');
    };

    Client.prototype.defaultFileServer = function() {
      return this.apiServer.replace('api.', 'api-content.');
    };

    Client.prototype.computeCredentials = function() {
      var value;
      value = {
        key: this.oauth.key,
        sandbox: this.sandbox
      };
      if (this.oauth.secret) {
        value.secret = this.oauth.secret;
      }
      if (this.oauth.token) {
        value.token = this.oauth.token;
        value.tokenSecret = this.oauth.tokenSecret;
      }
      if (this.uid) {
        value.uid = this.uid;
      }
      if (this.authState !== DropboxClient.ERROR && this.authState !== DropboxClient.RESET && this.authState !== DropboxClient.DONE && this.authState !== DropboxClient.SIGNED_OFF) {
        value.authState = this.authState;
      }
      if (this.apiServer !== this.defaultApiServer()) {
        value.server = this.apiServer;
      }
      if (this.authServer !== this.defaultAuthServer()) {
        value.authServer = this.authServer;
      }
      if (this.fileServer !== this.defaultFileServer()) {
        value.fileServer = this.fileServer;
      }
      return this._credentials = value;
    };

    return Client;

  })();

  DropboxClient = Dropbox.Client;

  Dropbox.AuthDriver = (function() {
    function AuthDriver() {}

    AuthDriver.prototype.url = function() {
      return 'https://some.url';
    };

    AuthDriver.prototype.doAuthorize = function(authUrl, token, tokenSecret, callback) {
      return callback('oauth-token');
    };

    AuthDriver.prototype.onAuthStateChange = function(client, done) {
      return done();
    };

    return AuthDriver;

  })();

  Dropbox.Drivers = {};

  Dropbox.Drivers.Redirect = (function() {
    function Redirect(options) {
      this.rememberUser = (options != null ? options.rememberUser : void 0) || false;
      this.scope = (options != null ? options.scope : void 0) || 'default';
      this.useQuery = (options != null ? options.useQuery : void 0) || false;
      this.receiverUrl = this.computeUrl(options);
      this.tokenRe = new RegExp("(#|\\?|&)oauth_token=([^&#]+)(&|#|$)");
    }

    Redirect.prototype.url = function() {
      return this.receiverUrl;
    };

    Redirect.prototype.doAuthorize = function(authUrl) {
      return window.location.assign(authUrl);
    };

    Redirect.prototype.onAuthStateChange = function(client, done) {
      var credentials,
        _this = this;
      this.storageKey = "dropbox-auth:" + this.scope + ":" + (client.appHash());
      switch (client.authState) {
        case DropboxClient.RESET:
          if (!(credentials = this.loadCredentials())) {
            return done();
          }
          if (credentials.authState) {
            if (credentials.token === this.locationToken()) {
              if (credentials.authState === DropboxClient.REQUEST) {
                this.forgetCredentials();
                credentials.authState = DropboxClient.AUTHORIZED;
              }
              client.setCredentials(credentials);
            }
            return done();
          }
          if (!this.rememberUser) {
            this.forgetCredentials();
            return done();
          }
          client.setCredentials(credentials);
          return client.getUserInfo(function(error) {
            if (error) {
              client.reset();
              _this.forgetCredentials();
            }
            return done();
          });
        case DropboxClient.REQUEST:
          this.storeCredentials(client.credentials());
          return done();
        case DropboxClient.DONE:
          if (this.rememberUser) {
            this.storeCredentials(client.credentials());
          }
          return done();
        case DropboxClient.SIGNED_OFF:
          this.forgetCredentials();
          return done();
        case DropboxClient.ERROR:
          this.forgetCredentials();
          return done();
        default:
          return done();
      }
    };

    Redirect.prototype.computeUrl = function() {
      var fragment, location, locationPair, querySuffix;
      querySuffix = "_dropboxjs_scope=" + (encodeURIComponent(this.scope));
      location = Dropbox.Drivers.Redirect.currentLocation();
      if (location.indexOf('#') === -1) {
        fragment = null;
      } else {
        locationPair = location.split('#', 2);
        location = locationPair[0];
        fragment = locationPair[1];
      }
      if (this.useQuery) {
        if (location.indexOf('?') === -1) {
          location += "?" + querySuffix;
        } else {
          location += "&" + querySuffix;
        }
      } else {
        fragment = "?" + querySuffix;
      }
      if (fragment) {
        return location + '#' + fragment;
      } else {
        return location;
      }
    };

    Redirect.prototype.locationToken = function() {
      var location, match, scopePattern;
      location = Dropbox.Drivers.Redirect.currentLocation();
      scopePattern = "_dropboxjs_scope=" + (encodeURIComponent(this.scope)) + "&";
      if ((typeof location.indexOf === "function" ? location.indexOf(scopePattern) : void 0) === -1) {
        return null;
      }
      match = this.tokenRe.exec(location);
      if (match) {
        return decodeURIComponent(match[2]);
      } else {
        return null;
      }
    };

    Redirect.currentLocation = function() {
      return window.location.href;
    };

    Redirect.prototype.storeCredentials = function(credentials) {
      return localStorage.setItem(this.storageKey, JSON.stringify(credentials));
    };

    Redirect.prototype.loadCredentials = function() {
      var e, jsonString;
      jsonString = localStorage.getItem(this.storageKey);
      if (!jsonString) {
        return null;
      }
      try {
        return JSON.parse(jsonString);
      } catch (_error) {
        e = _error;
        return null;
      }
    };

    Redirect.prototype.forgetCredentials = function() {
      return localStorage.removeItem(this.storageKey);
    };

    return Redirect;

  })();

  Dropbox.Drivers.Popup = (function() {
    function Popup(options) {
      this.receiverUrl = this.computeUrl(options);
      this.tokenRe = new RegExp("(#|\\?|&)oauth_token=([^&#]+)(&|#|$)");
    }

    Popup.prototype.doAuthorize = function(authUrl, token, tokenSecret, callback) {
      this.listenForMessage(token, callback);
      return this.openWindow(authUrl);
    };

    Popup.prototype.url = function() {
      return this.receiverUrl;
    };

    Popup.prototype.computeUrl = function(options) {
      var fragments;
      if (options) {
        if (options.receiverUrl) {
          if (options.noFragment || options.receiverUrl.indexOf('#') !== -1) {
            return options.receiverUrl;
          } else {
            return options.receiverUrl + '#';
          }
        } else if (options.receiverFile) {
          fragments = Dropbox.Drivers.Popup.currentLocation().split('/');
          fragments[fragments.length - 1] = options.receiverFile;
          if (options.noFragment) {
            return fragments.join('/');
          } else {
            return fragments.join('/') + '#';
          }
        }
      }
      return Dropbox.Drivers.Popup.currentLocation();
    };

    Popup.currentLocation = function() {
      return window.location.href;
    };

    Popup.prototype.openWindow = function(url) {
      return window.open(url, '_dropboxOauthSigninWindow', this.popupWindowSpec(980, 980));
    };

    Popup.prototype.popupWindowSpec = function(popupWidth, popupHeight) {
      var height, popupLeft, popupTop, width, x0, y0, _ref, _ref1, _ref2, _ref3;
      x0 = (_ref = window.screenX) != null ? _ref : window.screenLeft;
      y0 = (_ref1 = window.screenY) != null ? _ref1 : window.screenTop;
      width = (_ref2 = window.outerWidth) != null ? _ref2 : document.documentElement.clientWidth;
      height = (_ref3 = window.outerHeight) != null ? _ref3 : document.documentElement.clientHeight;
      popupLeft = Math.round(x0 + (width - popupWidth) / 2);
      popupTop = Math.round(y0 + (height - popupHeight) / 2.5);
      return ("width=" + popupWidth + ",height=" + popupHeight + ",") + ("left=" + popupLeft + ",top=" + popupTop) + 'dialog=yes,dependent=yes,scrollbars=yes,location=yes';
    };

    Popup.prototype.listenForMessage = function(token, callback) {
      var listener, tokenRe;
      tokenRe = this.tokenRe;
      listener = function(event) {
        var match;
        match = tokenRe.exec(event.data.toString());
        if (match && decodeURIComponent(match[2]) === token) {
          window.removeEventListener('message', listener);
          return callback();
        }
      };
      return window.addEventListener('message', listener, false);
    };

    return Popup;

  })();

  Dropbox.Drivers.NodeServer = (function() {
    function NodeServer(options) {
      this.port = (options != null ? options.port : void 0) || 8912;
      this.faviconFile = (options != null ? options.favicon : void 0) || null;
      this.fs = require('fs');
      this.http = require('http');
      this.open = require('open');
      this.callbacks = {};
      this.urlRe = new RegExp("^/oauth_callback\\?");
      this.tokenRe = new RegExp("(\\?|&)oauth_token=([^&]+)(&|$)");
      this.createApp();
    }

    NodeServer.prototype.url = function() {
      return "http://localhost:" + this.port + "/oauth_callback";
    };

    NodeServer.prototype.doAuthorize = function(authUrl, token, tokenSecret, callback) {
      this.callbacks[token] = callback;
      return this.openBrowser(authUrl);
    };

    NodeServer.prototype.openBrowser = function(url) {
      if (!url.match(/^https?:\/\//)) {
        throw new Error("Not a http/https URL: " + url);
      }
      return this.open(url);
    };

    NodeServer.prototype.createApp = function() {
      var _this = this;
      this.app = this.http.createServer(function(request, response) {
        return _this.doRequest(request, response);
      });
      return this.app.listen(this.port);
    };

    NodeServer.prototype.closeServer = function() {
      return this.app.close();
    };

    NodeServer.prototype.doRequest = function(request, response) {
      var data, match, token,
        _this = this;
      if (this.urlRe.exec(request.url)) {
        match = this.tokenRe.exec(request.url);
        if (match) {
          token = decodeURIComponent(match[2]);
          if (this.callbacks[token]) {
            this.callbacks[token]();
            delete this.callbacks[token];
          }
        }
      }
      data = '';
      request.on('data', function(dataFragment) {
        return data += dataFragment;
      });
      return request.on('end', function() {
        if (_this.faviconFile && (request.url === '/favicon.ico')) {
          return _this.sendFavicon(response);
        } else {
          return _this.closeBrowser(response);
        }
      });
    };

    NodeServer.prototype.closeBrowser = function(response) {
      var closeHtml;
      closeHtml = "<!doctype html>\n<script type=\"text/javascript\">window.close();</script>\n<p>Please close this window.</p>";
      response.writeHead(200, {
        'Content-Length': closeHtml.length,
        'Content-Type': 'text/html'
      });
      response.write(closeHtml);
      return response.end;
    };

    NodeServer.prototype.sendFavicon = function(response) {
      return this.fs.readFile(this.faviconFile, function(error, data) {
        response.writeHead(200, {
          'Content-Length': data.length,
          'Content-Type': 'image/x-icon'
        });
        response.write(data);
        return response.end;
      });
    };

    return NodeServer;

  })();

  base64HmacSha1 = function(string, key) {
    return arrayToBase64(hmacSha1(stringToArray(string), stringToArray(key), string.length, key.length));
  };

  base64Sha1 = function(string) {
    return arrayToBase64(sha1(stringToArray(string), string.length));
  };

  if (typeof window === "undefined" || window === null) {
    crypto = require('crypto');
    base64HmacSha1 = function(string, key) {
      var hmac;
      hmac = crypto.createHmac('sha1', key);
      hmac.update(string);
      return hmac.digest('base64');
    };
    base64Sha1 = function(string) {
      var hash;
      hash = crypto.createHash('sha1');
      hash.update(string);
      return hash.digest('base64');
    };
  }

  hmacSha1 = function(string, key, length, keyLength) {
    var hash1, i, ipad, opad;
    if (key.length > 16) {
      key = sha1(key, keyLength);
    }
    ipad = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i < 16; i = ++_i) {
        _results.push(key[i] ^ 0x36363636);
      }
      return _results;
    })();
    opad = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i < 16; i = ++_i) {
        _results.push(key[i] ^ 0x5C5C5C5C);
      }
      return _results;
    })();
    hash1 = sha1(ipad.concat(string), 64 + length);
    return sha1(opad.concat(hash1), 64 + 20);
  };

  sha1 = function(string, length) {
    var a, a0, b, b0, c, c0, d, d0, e, e0, ft, i, j, kt, limit, state, t, _i;
    string[length >> 2] |= 1 << (31 - ((length & 0x03) << 3));
    string[(((length + 8) >> 6) << 4) + 15] = length << 3;
    state = Array(80);
    a = 1732584193;
    b = -271733879;
    c = -1732584194;
    d = 271733878;
    e = -1009589776;
    i = 0;
    limit = string.length;
    while (i < limit) {
      a0 = a;
      b0 = b;
      c0 = c;
      d0 = d;
      e0 = e;
      for (j = _i = 0; _i < 80; j = ++_i) {
        if (j < 16) {
          state[j] = string[i + j];
        } else {
          state[j] = rotateLeft32(state[j - 3] ^ state[j - 8] ^ state[j - 14] ^ state[j - 16], 1);
        }
        if (j < 20) {
          ft = (b & c) | ((~b) & d);
          kt = 1518500249;
        } else if (j < 40) {
          ft = b ^ c ^ d;
          kt = 1859775393;
        } else if (j < 60) {
          ft = (b & c) | (b & d) | (c & d);
          kt = -1894007588;
        } else {
          ft = b ^ c ^ d;
          kt = -899497514;
        }
        t = add32(add32(rotateLeft32(a, 5), ft), add32(add32(e, state[j]), kt));
        e = d;
        d = c;
        c = rotateLeft32(b, 30);
        b = a;
        a = t;
      }
      a = add32(a, a0);
      b = add32(b, b0);
      c = add32(c, c0);
      d = add32(d, d0);
      e = add32(e, e0);
      i += 16;
    }
    return [a, b, c, d, e];
  };

  /*
  # Uncomment the definition below for debugging.
  #
  # Returns the hexadecimal representation of a 32-bit number.
  xxx = (n) ->
    if n < 0
      n = (1 << 30) * 4 + n
    n.toString 16
  */


  rotateLeft32 = function(value, count) {
    return (value << count) | (value >>> (32 - count));
  };

  add32 = function(a, b) {
    var high, low;
    low = (a & 0xFFFF) + (b & 0xFFFF);
    high = (a >> 16) + (b >> 16) + (low >> 16);
    return (high << 16) | (low & 0xFFFF);
  };

  arrayToBase64 = function(array) {
    var i, i2, limit, string, trit;
    string = "";
    i = 0;
    limit = array.length * 4;
    while (i < limit) {
      i2 = i;
      trit = ((array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF) << 16;
      i2 += 1;
      trit |= ((array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF) << 8;
      i2 += 1;
      trit |= (array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF;
      string += _base64Digits[(trit >> 18) & 0x3F];
      string += _base64Digits[(trit >> 12) & 0x3F];
      i += 1;
      if (i >= limit) {
        string += '=';
      } else {
        string += _base64Digits[(trit >> 6) & 0x3F];
      }
      i += 1;
      if (i >= limit) {
        string += '=';
      } else {
        string += _base64Digits[trit & 0x3F];
      }
      i += 1;
    }
    return string;
  };

  _base64Digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  stringToArray = function(string) {
    var array, i, mask, _i, _ref;
    array = [];
    mask = 0xFF;
    for (i = _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      array[i >> 2] |= (string.charCodeAt(i) & mask) << ((3 - (i & 3)) << 3);
    }
    return array;
  };

  Dropbox.Oauth = (function() {
    function Oauth(options) {
      this.key = this.k = null;
      this.secret = this.s = null;
      this.token = null;
      this.tokenSecret = null;
      this._appHash = null;
      this.reset(options);
    }

    Oauth.prototype.reset = function(options) {
      var k, s, secret, _ref;
      if (options.secret) {
        this.k = this.key = options.key;
        this.s = this.secret = options.secret;
        this._appHash = null;
      } else if (options.key) {
        this.key = options.key;
        this.secret = null;
        secret = atob(dropboxEncodeKey(this.key).split('|', 2)[1]);
        _ref = secret.split('?', 2), k = _ref[0], s = _ref[1];
        this.k = decodeURIComponent(k);
        this.s = decodeURIComponent(s);
        this._appHash = null;
      } else {
        if (!this.k) {
          throw new Error('No API key supplied');
        }
      }
      if (options.token) {
        return this.setToken(options.token, options.tokenSecret);
      } else {
        return this.setToken(null, '');
      }
    };

    Oauth.prototype.setToken = function(token, tokenSecret) {
      if (token && (!tokenSecret)) {
        throw new Error('No secret supplied with the user token');
      }
      this.token = token;
      this.tokenSecret = tokenSecret || '';
      this.hmacKey = DropboxXhr.urlEncodeValue(this.s) + '&' + DropboxXhr.urlEncodeValue(tokenSecret);
      return null;
    };

    Oauth.prototype.authHeader = function(method, url, params) {
      var header, oauth_params, param, value, _i, _len;
      this.addAuthParams(method, url, params);
      oauth_params = [];
      for (param in params) {
        value = params[param];
        if (param.substring(0, 6) === 'oauth_') {
          oauth_params.push(param);
        }
      }
      oauth_params.sort();
      header = [];
      for (_i = 0, _len = oauth_params.length; _i < _len; _i++) {
        param = oauth_params[_i];
        header.push(DropboxXhr.urlEncodeValue(param) + '="' + DropboxXhr.urlEncodeValue(params[param]) + '"');
        delete params[param];
      }
      return 'OAuth ' + header.join(',');
    };

    Oauth.prototype.addAuthParams = function(method, url, params) {
      this.boilerplateParams(params);
      params.oauth_signature = this.signature(method, url, params);
      return params;
    };

    Oauth.prototype.boilerplateParams = function(params) {
      params.oauth_consumer_key = this.k;
      params.oauth_nonce = this.nonce();
      params.oauth_signature_method = 'HMAC-SHA1';
      if (this.token) {
        params.oauth_token = this.token;
      }
      params.oauth_timestamp = Math.floor(Date.now() / 1000);
      params.oauth_version = '1.0';
      return params;
    };

    Oauth.prototype.nonce = function() {
      return Date.now().toString(36) + Math.random().toString(36);
    };

    Oauth.prototype.signature = function(method, url, params) {
      var string;
      string = method.toUpperCase() + '&' + DropboxXhr.urlEncodeValue(url) + '&' + DropboxXhr.urlEncodeValue(DropboxXhr.urlEncode(params));
      return base64HmacSha1(string, this.hmacKey);
    };

    Oauth.prototype.appHash = function() {
      if (this._appHash) {
        return this._appHash;
      }
      return this._appHash = base64Sha1(this.k).replace(/\=/g, '');
    };

    return Oauth;

  })();

  if (Date.now == null) {
    Date.now = function() {
      return (new Date()).getTime();
    };
  }

  DropboxOauth = Dropbox.Oauth;

  dropboxEncodeKey = function(key, secret) {
    var i, k, result, s, x, y, z, _i, _j, _ref, _ref1, _results;
    if (secret) {
      secret = [encodeURIComponent(key), encodeURIComponent(secret)].join('?');
      key = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = key.length / 2; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(((key.charCodeAt(i * 2) & 15) * 16) + (key.charCodeAt(i * 2 + 1) & 15));
        }
        return _results;
      })();
    } else {
      _ref = key.split('|', 2), key = _ref[0], secret = _ref[1];
      key = atob(key);
      key = (function() {
        var _i, _ref1, _results;
        _results = [];
        for (i = _i = 0, _ref1 = key.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          _results.push(key.charCodeAt(i));
        }
        return _results;
      })();
      secret = atob(secret);
    }
    s = (function() {
      _results = [];
      for (_i = 0; _i < 256; _i++){ _results.push(_i); }
      return _results;
    }).apply(this);
    y = 0;
    for (x = _j = 0; _j < 256; x = ++_j) {
      y = (y + s[i] + key[x % key.length]) % 256;
      _ref1 = [s[y], s[x]], s[x] = _ref1[0], s[y] = _ref1[1];
    }
    x = y = 0;
    result = (function() {
      var _k, _ref2, _ref3, _results1;
      _results1 = [];
      for (z = _k = 0, _ref2 = secret.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; z = 0 <= _ref2 ? ++_k : --_k) {
        x = (x + 1) % 256;
        y = (y + s[x]) % 256;
        _ref3 = [s[y], s[x]], s[x] = _ref3[0], s[y] = _ref3[1];
        k = s[(s[x] + s[y]) % 256];
        _results1.push(String.fromCharCode((k ^ secret.charCodeAt(z)) % 256));
      }
      return _results1;
    })();
    key = (function() {
      var _k, _ref2, _results1;
      _results1 = [];
      for (i = _k = 0, _ref2 = key.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        _results1.push(String.fromCharCode(key[i]));
      }
      return _results1;
    })();
    return [btoa(key.join('')), btoa(result.join(''))].join('|');
  };

  Dropbox.PulledChanges = (function() {
    PulledChanges.parse = function(deltaInfo) {
      if (deltaInfo && typeof deltaInfo === 'object') {
        return new Dropbox.PulledChanges(deltaInfo);
      } else {
        return deltaInfo;
      }
    };

    PulledChanges.prototype.blankSlate = void 0;

    PulledChanges.prototype.cursorTag = void 0;

    PulledChanges.prototype.changes = void 0;

    PulledChanges.prototype.shouldPullAgain = void 0;

    PulledChanges.prototype.shouldBackOff = void 0;

    function PulledChanges(deltaInfo) {
      var entry;
      this.blankSlate = deltaInfo.reset || false;
      this.cursorTag = deltaInfo.cursor;
      this.shouldPullAgain = deltaInfo.has_more;
      this.shouldBackOff = !this.shouldPullAgain;
      if (deltaInfo.cursor && deltaInfo.cursor.length) {
        this.changes = (function() {
          var _i, _len, _ref, _results;
          _ref = deltaInfo.entries;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            entry = _ref[_i];
            _results.push(Dropbox.PullChange.parse(entry));
          }
          return _results;
        })();
      } else {
        this.changes = [];
      }
    }

    return PulledChanges;

  })();

  Dropbox.PullChange = (function() {
    PullChange.parse = function(entry) {
      if (entry && typeof entry === 'object') {
        return new Dropbox.PullChange(entry);
      } else {
        return entry;
      }
    };

    PullChange.prototype.path = void 0;

    PullChange.prototype.wasRemoved = void 0;

    PullChange.prototype.stat = void 0;

    function PullChange(entry) {
      this.path = entry[0];
      this.stat = Dropbox.Stat.parse(entry[1]);
      if (this.stat) {
        this.wasRemoved = false;
      } else {
        this.stat = null;
        this.wasRemoved = true;
      }
    }

    return PullChange;

  })();

  Dropbox.PublicUrl = (function() {
    PublicUrl.parse = function(urlData, isDirect) {
      if (urlData && typeof urlData === 'object') {
        return new Dropbox.PublicUrl(urlData, isDirect);
      } else {
        return urlData;
      }
    };

    PublicUrl.prototype.url = void 0;

    PublicUrl.prototype.expiresAt = void 0;

    PublicUrl.prototype.isDirect = void 0;

    PublicUrl.prototype.isPreview = void 0;

    function PublicUrl(urlData, isDirect) {
      this.url = urlData.url;
      this.expiresAt = new Date(Date.parse(urlData.expires));
      if (isDirect === true) {
        this.isDirect = true;
      } else if (isDirect === false) {
        this.isDirect = false;
      } else {
        this.isDirect = Date.now() - this.expiresAt <= 86400000;
      }
      this.isPreview = !this.isDirect;
    }

    return PublicUrl;

  })();

  Dropbox.CopyReference = (function() {
    CopyReference.parse = function(refData) {
      if (refData && (typeof refData === 'object' || typeof refData === 'string')) {
        return new Dropbox.CopyReference(refData);
      } else {
        return refData;
      }
    };

    CopyReference.prototype.tag = void 0;

    CopyReference.prototype.expiresAt = void 0;

    function CopyReference(refData) {
      if (typeof refData === 'object') {
        this.tag = refData.copy_ref;
        this.expiresAt = new Date(Date.parse(refData.expires));
      } else {
        this.tag = refData;
        this.expiresAt = new Date();
      }
    }

    return CopyReference;

  })();

  Dropbox.Stat = (function() {
    Stat.parse = function(metadata) {
      if (metadata && typeof metadata === 'object') {
        return new Dropbox.Stat(metadata);
      } else {
        return metadata;
      }
    };

    Stat.prototype.path = null;

    Stat.prototype.name = null;

    Stat.prototype.inAppFolder = null;

    Stat.prototype.isFolder = null;

    Stat.prototype.isFile = null;

    Stat.prototype.isRemoved = null;

    Stat.prototype.typeIcon = null;

    Stat.prototype.versionTag = null;

    Stat.prototype.mimeType = null;

    Stat.prototype.size = null;

    Stat.prototype.humanSize = null;

    Stat.prototype.hasThumbnail = null;

    Stat.prototype.modifiedAt = null;

    Stat.prototype.clientModifiedAt = null;

    function Stat(metadata) {
      var lastIndex, nameSlash, _ref, _ref1;
      this.path = metadata.path;
      if (this.path.substring(0, 1) !== '/') {
        this.path = '/' + this.path;
      }
      lastIndex = this.path.length - 1;
      if (lastIndex >= 0 && this.path.substring(lastIndex) === '/') {
        this.path = this.path.substring(0, lastIndex);
      }
      nameSlash = this.path.lastIndexOf('/');
      this.name = this.path.substring(nameSlash + 1);
      this.isFolder = metadata.is_dir || false;
      this.isFile = !this.isFolder;
      this.isRemoved = metadata.is_deleted || false;
      this.typeIcon = metadata.icon;
      if ((_ref = metadata.modified) != null ? _ref.length : void 0) {
        this.modifiedAt = new Date(Date.parse(metadata.modified));
      } else {
        this.modifiedAt = null;
      }
      if ((_ref1 = metadata.client_mtime) != null ? _ref1.length : void 0) {
        this.clientModifiedAt = new Date(Date.parse(metadata.client_mtime));
      } else {
        this.clientModifiedAt = null;
      }
      switch (metadata.root) {
        case 'dropbox':
          this.inAppFolder = false;
          break;
        case 'app_folder':
          this.inAppFolder = true;
          break;
        default:
          this.inAppFolder = null;
      }
      this.size = metadata.bytes || 0;
      this.humanSize = metadata.size || '';
      this.hasThumbnail = metadata.thumb_exists || false;
      if (this.isFolder) {
        this.versionTag = metadata.hash;
        this.mimeType = metadata.mime_type || 'inode/directory';
      } else {
        this.versionTag = metadata.rev;
        this.mimeType = metadata.mime_type || 'application/octet-stream';
      }
    }

    return Stat;

  })();

  Dropbox.UserInfo = (function() {
    UserInfo.parse = function(userInfo) {
      if (userInfo && typeof userInfo === 'object') {
        return new Dropbox.UserInfo(userInfo);
      } else {
        return userInfo;
      }
    };

    UserInfo.prototype.name = null;

    UserInfo.prototype.email = null;

    UserInfo.prototype.countryCode = null;

    UserInfo.prototype.uid = null;

    UserInfo.prototype.referralUrl = null;

    UserInfo.prototype.publicAppUrl = null;

    UserInfo.prototype.quota = null;

    UserInfo.prototype.usedQuota = null;

    UserInfo.prototype.privateBytes = null;

    UserInfo.prototype.sharedBytes = null;

    function UserInfo(userInfo) {
      var lastIndex;
      this.name = userInfo.display_name;
      this.email = userInfo.email;
      this.countryCode = userInfo.country || null;
      this.uid = userInfo.uid.toString();
      if (userInfo.public_app_url) {
        this.publicAppUrl = userInfo.public_app_url;
        lastIndex = this.publicAppUrl.length - 1;
        if (lastIndex >= 0 && this.publicAppUrl.substring(lastIndex) === '/') {
          this.publicAppUrl = this.publicAppUrl.substring(0, lastIndex);
        }
      } else {
        this.publicAppUrl = null;
      }
      this.referralUrl = userInfo.referral_link;
      this.quota = userInfo.quota_info.quota;
      this.privateBytes = userInfo.quota_info.normal || 0;
      this.sharedBytes = userInfo.quota_info.shared || 0;
      this.usedQuota = this.privateBytes + this.sharedBytes;
    }

    return UserInfo;

  })();

  if (typeof window !== "undefined" && window !== null) {
    if (window.XDomainRequest && !('withCredentials' in new XMLHttpRequest())) {
      DropboxXhrRequest = window.XDomainRequest;
      DropboxXhrIeMode = true;
      DropboxXhrCanSendForms = false;
    } else {
      DropboxXhrRequest = window.XMLHttpRequest;
      DropboxXhrIeMode = false;
      DropboxXhrCanSendForms = window.navigator.userAgent.indexOf('Firefox') === -1;
    }
  } else {
    DropboxXhrRequest = require('xmlhttprequest').XMLHttpRequest;
    DropboxXhrIeMode = false;
    DropboxXhrCanSendForms = false;
  }

  Dropbox.Xhr = (function() {
    function Xhr() {}

    Xhr.Request = DropboxXhrRequest;

    Xhr.ieMode = DropboxXhrIeMode;

    Xhr.canSendForms = DropboxXhrCanSendForms;

    Xhr.request = function(method, url, params, authHeader, callback) {
      return this.request2(method, url, params, authHeader, null, null, callback);
    };

    Xhr.request2 = function(method, url, params, authHeader, body, responseType, callback) {
      var headers, paramsInUrl, queryString;
      paramsInUrl = method === 'GET' || (body != null) || this.ieMode;
      if (paramsInUrl) {
        queryString = DropboxXhr.urlEncode(params);
        if (queryString.length !== 0) {
          url = [url, '?', DropboxXhr.urlEncode(params)].join('');
        }
      }
      headers = {};
      if (authHeader) {
        headers['Authorization'] = authHeader;
      }
      if (body != null) {
        if (typeof body === 'string') {
          headers['Content-Type'] = 'text/plain; charset=utf8';
        }
      } else if (!paramsInUrl) {
        headers['Content-Type'] = 'application/x-www-form-urlencoded';
        body = DropboxXhr.urlEncode(params);
      }
      return DropboxXhr.xhrRequest(method, url, headers, body, responseType, callback);
    };

    Xhr.multipartRequest = function(url, fileField, params, authHeader, callback) {
      var body, boundary, fileData, fileType, headers, useFormData;
      url = [url, '?', DropboxXhr.urlEncode(params)].join('');
      fileData = fileField.value;
      useFormData = (typeof fileData === 'object') && (((typeof Blob !== "undefined" && Blob !== null) && (fileField.value instanceof Blob)) || ((typeof File !== "undefined" && File !== null) && (fileField.value instanceof File)));
      if (useFormData) {
        headers = {};
        body = new FormData();
        body.append(fileField.name, fileData, fileField.fileName);
      } else {
        fileType = fileField.contentType || 'application/octet-stream';
        boundary = this.multipartBoundary();
        headers = {
          'Content-Type': "multipart/form-data; boundary=" + boundary
        };
        body = ['--', boundary, "\r\n", 'Content-Disposition: form-data; name="', fileField.name, '"; filename="', fileField.fileName, "\"\r\n", 'Content-Type: ', fileType, "\r\n", "Content-Transfer-Encoding: binary\r\n\r\n", fileData, "\r\n", '--', boundary, '--', "\r\n"].join('');
      }
      if (authHeader) {
        headers['Authorization'] = authHeader;
      }
      return DropboxXhr.xhrRequest('POST', url, headers, body, null, callback);
    };

    Xhr.multipartBoundary = function() {
      return [Date.now().toString(36), Math.random().toString(36)].join('----');
    };

    Xhr.xhrRequest = function(method, url, headers, body, responseType, callback) {
      var header, value, xhr;
      xhr = new this.Request();
      if (this.ieMode) {
        xhr.onload = function() {
          return DropboxXhr.onLoad(xhr, method, url, callback);
        };
        xhr.onerror = function() {
          return DropboxXhr.onError(xhr, method, url, callback);
        };
      } else {
        xhr.onreadystatechange = function() {
          return DropboxXhr.onReadyStateChange(xhr, method, url, responseType, callback);
        };
      }
      xhr.open(method, url, true);
      if (responseType) {
        if (responseType === 'b') {
          if (xhr.overrideMimeType) {
            xhr.overrideMimeType('text/plain; charset=x-user-defined');
          }
        } else {
          xhr.responseType = responseType;
        }
      }
      if (!this.ieMode) {
        for (header in headers) {
          if (!__hasProp.call(headers, header)) continue;
          value = headers[header];
          xhr.setRequestHeader(header, value);
        }
      }
      if (body != null) {
        xhr.send(body);
      } else {
        xhr.send();
      }
      return xhr;
    };

    Xhr.urlEncode = function(object) {
      var chunks, key, value;
      chunks = [];
      for (key in object) {
        value = object[key];
        chunks.push(this.urlEncodeValue(key) + '=' + this.urlEncodeValue(value));
      }
      return chunks.sort().join('&');
    };

    Xhr.urlEncodeValue = function(object) {
      return encodeURIComponent(object.toString()).replace(/\!/g, '%21').replace(/'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/\*/g, '%2A');
    };

    Xhr.urlDecode = function(string) {
      var kvp, result, token, _i, _len, _ref;
      result = {};
      _ref = string.split('&');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        token = _ref[_i];
        kvp = token.split('=');
        result[decodeURIComponent(kvp[0])] = decodeURIComponent(kvp[1]);
      }
      return result;
    };

    Xhr.onReadyStateChange = function(xhr, method, url, responseType, callback) {
      var apiError, bytes, dirtyText, e, i, metadata, metadataJson, text, _i, _ref;
      if (xhr.readyState !== 4) {
        return true;
      }
      if (xhr.status < 200 || xhr.status >= 300) {
        apiError = new Dropbox.ApiError(xhr, method, url);
        callback(apiError);
        return true;
      }
      metadataJson = xhr.getResponseHeader('x-dropbox-metadata');
      if (metadataJson != null ? metadataJson.length : void 0) {
        try {
          metadata = JSON.parse(metadataJson);
        } catch (_error) {
          e = _error;
          metadata = void 0;
        }
      } else {
        metadata = void 0;
      }
      if (responseType) {
        if (responseType === 'b') {
          dirtyText = xhr.responseText != null ? xhr.responseText : xhr.response;
          /*
          jsString = ['["']
          for i in [0...dirtyText.length]
            hexByte = (dirtyText.charCodeAt(i) & 0xFF).toString(16)
            if hexByte.length is 2
              jsString.push "\\u00#{hexByte}"
            else
              jsString.push "\\u000#{hexByte}"
          jsString.push '"]'
          console.log jsString
          text = JSON.parse(jsString.join(''))[0]
          */

          bytes = [];
          for (i = _i = 0, _ref = dirtyText.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            bytes.push(String.fromCharCode(dirtyText.charCodeAt(i) & 0xFF));
          }
          text = bytes.join('');
          callback(null, text, metadata);
        } else {
          callback(null, xhr.response, metadata);
        }
        return true;
      }
      text = xhr.responseText != null ? xhr.responseText : xhr.response;
      switch (xhr.getResponseHeader('Content-Type')) {
        case 'application/x-www-form-urlencoded':
          callback(null, DropboxXhr.urlDecode(text), metadata);
          break;
        case 'application/json':
        case 'text/javascript':
          callback(null, JSON.parse(text), metadata);
          break;
        default:
          callback(null, text, metadata);
      }
      return true;
    };

    Xhr.onLoad = function(xhr, method, url, callback) {
      var text;
      text = xhr.responseText;
      switch (xhr.contentType) {
        case 'application/x-www-form-urlencoded':
          callback(null, DropboxXhr.urlDecode(text), void 0);
          break;
        case 'application/json':
        case 'text/javascript':
          callback(null, JSON.parse(text), void 0);
          break;
        default:
          callback(null, text, void 0);
      }
      return true;
    };

    Xhr.onError = function(xhr, method, url, callback) {
      var apiError;
      apiError = new Dropbox.ApiError(xhr, method, url);
      callback(apiError);
      return true;
    };

    return Xhr;

  })();

  DropboxXhr = Dropbox.Xhr;

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = Dropbox;
  } else if (typeof window !== "undefined" && window !== null) {
    window.Dropbox = Dropbox;
  } else {
    throw new Error('This library only supports node.js and modern browsers.');
  }

  Dropbox.atob = atob;

  Dropbox.btoa = btoa;

  Dropbox.hmac = base64HmacSha1;

  Dropbox.sha1 = base64Sha1;

  Dropbox.encodeKey = dropboxEncodeKey;

  (function() {
    var $, Auth, Binary, Class, Client, DB, Events, Model, Nimbus, Share, isArray, makeArray, moduleKeywords;
    if (window.Nimbus == null) {
      Nimbus = winodw.Nimbus = {};
    }
    Nimbus = window.Nimbus;
    Nimbus.version = "0.0.1";
    $ = Nimbus.$ = this.jQuery || this.Zepto || function() {
      return arguments[0];
    };
    Nimbus.dictModel = {};
    makeArray = function(args) {
      return Array.prototype.slice.call(args, 0);
    };
    isArray = function(value) {
      return Object.prototype.toString.call(value) === "[object Array]";
    };
    if (typeof Array.prototype.indexOf === "undefined") {
      Array.prototype.indexOf = function(value) {
        var i;
        i = 0;
        while (i < this.length) {
          if (this[i] === value) {
            return i;
          }
          i++;
        }
        return -1;
      };
    }
    Events = {
      bind: function(ev, callback) {
        var calls, evs, i;
        evs = ev.split(" ");
        calls = this._callbacks || (this._callbacks = {});
        i = 0;
        while (i < evs.length) {
          (this._callbacks[evs[i]] || (this._callbacks[evs[i]] = [])).push(callback);
          i++;
        }
        return this;
      },
      trigger: function() {
        var args, calls, ev, i, l, list;
        args = makeArray(arguments);
        ev = args.shift();
        if (!(calls = this._callbacks)) {
          return false;
        }
        if (!(list = this._callbacks[ev])) {
          return false;
        }
        i = 0;
        l = list.length;
        while (i < l) {
          if (list[i].apply(this, args) === false) {
            return false;
          }
          i++;
        }
        return true;
      },
      unbind: function(ev, callback) {
        var calls, i, l, list;
        if (!ev) {
          this._callbacks = {};
          return this;
        }
        if (!(calls = this._callbacks)) {
          return this;
        }
        if (!(list = calls[ev])) {
          return this;
        }
        if (!callback) {
          delete this._callbacks[ev];
          return this;
        }
        i = 0;
        l = list.length;
        while (i < l) {
          if (callback === list[i]) {
            list = list.slice();
            list.splice(i, 1);
            calls[ev] = list;
            break;
          }
          i++;
        }
        return this;
      }
    };
    if (typeof Object.create !== "function") {
      Object.create = function(o) {
        var F;
        F = function() {};
        F.prototype = o;
        return new F();
      };
    }
    moduleKeywords = ["included", "extended"];
    Class = {
      inherited: function() {},
      created: function() {},
      prototype: {
        initialize: function() {},
        init: function() {}
      },
      create: function(include, extend) {
        var object;
        object = Object.create(this);
        object.parent = this;
        object.prototype = object.fn = Object.create(this.prototype);
        if (include) {
          object.include(include);
        }
        if (extend) {
          object.extend(extend);
        }
        object.created();
        this.inherited(object);
        return object;
      },
      init: function() {
        var instance;
        instance = Object.create(this.prototype);
        instance.parent = this;
        instance.initialize.apply(instance, arguments);
        instance.init.apply(instance, arguments);
        return instance;
      },
      proxy: function(func) {
        var thisObject;
        thisObject = this;
        return function() {
          return func.apply(thisObject, arguments);
        };
      },
      proxyAll: function() {
        var functions, i, _results;
        functions = makeArray(arguments);
        i = 0;
        _results = [];
        while (i < functions.length) {
          this[functions[i]] = this.proxy(this[functions[i]]);
          _results.push(i++);
        }
        return _results;
      },
      include: function(obj) {
        var included, key;
        for (key in obj) {
          if (moduleKeywords.indexOf(key) === -1) {
            this.fn[key] = obj[key];
          }
        }
        included = obj.included;
        if (included) {
          included.apply(this);
        }
        return this;
      },
      extend: function(obj) {
        var extended, key;
        for (key in obj) {
          if (moduleKeywords.indexOf(key) === -1) {
            this[key] = obj[key];
          }
        }
        extended = obj.extended;
        if (extended) {
          extended.apply(this);
        }
        return this;
      }
    };
    Class.prototype.proxy = Class.proxy;
    Class.prototype.proxyAll = Class.proxyAll;
    Class.inst = Class.init;
    Class.sub = Class.create;
    Nimbus.guid = function() {
      var id, verified, verify_guide;
      verify_guide = function(g_id) {
        var x, y, _ref;
        _ref = Nimbus.dictModel;
        for (x in _ref) {
          y = _ref[x];
          if (y.exists(g_id)) {
            return false;
          }
        }
        return true;
      };
      verified = false;
      while (!verified) {
        id = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
          var r, v;
          r = Math.random() * 16 | 0;
          v = (c === "x" ? r : r & 0x3 | 0x8);
          return v.toString(16);
        }).toUpperCase();
        verified = verify_guide(id);
      }
      return id;
    };
    Auth = Nimbus.Auth = Class.create();
    Auth.extend({
      reinitialize: function() {
        log("reintialize called");
        if (localStorage["service"] != null) {
          log("the service exists", localStorage["service"]);
          this.setup(localStorage["service"], localStorage["d_key"], localStorage["secret"], localStorage["app_name"]);
          return this.initialize();
        }
      },
      setup: function(sync_service, key, secret, app_name, client_secret) {
        if (typeof sync_service === "string" && ((key == null) || (secret == null) || (app_name == null))) {
          sync_service = JSON.parse(Base64.decode(sync_service));
        }
        if (typeof sync_service === "string") {
          log("setup called");
          this.service = sync_service;
          this.key = key;
          this.secret = secret;
          this.app_name = app_name;
          if (client_secret != null) {
            this.client_secret = client_secret;
          }
          localStorage["service"] = this.service;
          localStorage["d_key"] = this.key;
          localStorage["secret"] = this.secret;
          localStorage["app_name"] = this.app_name;
          if (client_secret != null) {
            localStorage["client_secret"] = this.client_secret;
          }
          switch (this.service) {
            case "Dropbox":
              this.extend(Nimbus.Auth.Dropbox_auth);
              this.authorize = this.proxy(this.authenticate_dropbox);
              this.initialize = this.proxy(this.initialize_dropbox);
              this.authorized = this.proxy(this.dropbox_authorized);
              this.logout = this.proxy(this.logout_dropbox);
              log("service is dropbox");
              break;
            case "GDrive":
              this.extend(Nimbus.Auth.GDrive);
              this.authorize = this.proxy(this.authenticate_gdrive);
              this.initialize = this.proxy(this.initialize_gdrive);
              this.authorized = this.proxy(this.gdrive_authorized);
              this.logout = this.proxy(this.logout_gdrive);
              log("service is GDrive");
              Nimbus.Share.setup(this.service);
              break;
            case "Realtime":
              startRealtime(key, app_name);
              break;
            default:
              log("Invalid service name");
          }
          Nimbus.Binary.setup(this.service);
        } else if (typeof sync_service === "object") {
          log("new method for setup, the service is there");
          this.sync_services = sync_service;
          this.models = {};
          if (localStorage["service"] != null) {
            if (localStorage["service"] === "GDrive") {
              this.setup(localStorage["service"], localStorage["d_key"], localStorage["secret"], localStorage["app_name"], localStorage["client_secret"]);
            } else {
              this.setup(localStorage["service"], localStorage["d_key"], localStorage["secret"], localStorage["app_name"]);
            }
          } else {
            this.extend(Nimbus.Auth.Multi);
            this.authorize = this.proxy(this.authenticate_service);
            this.initialize = this.proxy(this.initialize_service);
          }
        }
      },
      authorized: function() {
        return log("authorized not yet setup");
      },
      state: function() {
        return localStorage["state"];
      },
      authorize: function() {
        return log("authorize not yet setup");
      },
      initialize: function() {
        return log("initialize not setup");
      },
      authorized_callback: function() {
        return log("authorized callback undefined");
      },
      app_ready_func: function() {
        log("app_ready");
        return this.app_ready = true;
      },
      set_app_ready: function(callback) {
        log("set app ready");
        if ((this.app_ready != null) && this.app_ready) {
          return callback();
        } else {
          return this.app_ready_func = callback;
        }
      },
      logout: function() {
        return log("logout not implemented");
      }
    });
    Client = Nimbus.Client = Class.create();
    Share = Nimbus.Share = Class.create();
    Share.extend({
      setup: function(sync_service) {
        switch (sync_service) {
          case "GDrive":
            log("share api with GDrive");
            this.extend(Nimbus.Client.GDrive);
            this.get_users = this.proxy(this.get_shared_users);
            this.add_user = this.proxy(this.add_share_user);
            this.remove_user = this.proxy(this.remove_share_user);
            this.get_me = this.proxy(this.get_current_user);
            this.get_spaces = this.proxy(this.get_app_folders);
            this.switch_spaces = this.proxy(this.switch_to_app_folder);
            return this.switch_file_real = this.proxy(this.switch_to_app_file_real);
          default:
            return log("share not supported with this service");
        }
      },
      get_users: function() {
        return log("users not implemented");
      },
      add_user: function(email) {
        return log("add a user");
      },
      remove_user: function(id) {
        return log("removed user");
      },
      get_me: function() {
        return log("get currently logged user");
      },
      get_spaces: function() {
        return log("get current spaces");
      },
      switch_spaces: function(id) {
        return log("switch space");
      }
    });
    Binary = Nimbus.Binary = Class.create();
    Binary.extend({
      setup: function(sync_service) {
        log("binary setup called");
        switch (sync_service) {
          case "Dropbox":
            this.extend(Nimbus.Client.Dropbox.Binary);
            Nimbus.Client.Dropbox.Binary.binary_setup();
            return log("service is dropbox");
          case "GDrive":
            this.extend(Nimbus.Client.GDrive.Binary);
            Nimbus.Client.GDrive.Binary.binary_setup();
            return log("service is GDrive");
          case "Realtime":
            return log("service is  Realtime");
          default:
            return log("Invalid service name");
        }
      },
      upload_blob: function(blob, name, callback) {
        return log("upload blob");
      },
      upload_file: function(file, callback) {
        return log("upload blob");
      },
      read_file: function(binary, callback) {
        return log("read file");
      },
      share_link: function(binary, callback) {
        return log("share link");
      },
      direct_link: function(binary, callback) {
        return log("direct link");
      },
      delete_file: function(binary) {
        return log("delete file");
      }
    });
    DB = Nimbus.DB = Class.create();
    DB.extend(Events);
    DB.extend({
      setup_db: function(type) {
        log("setup db");
        switch (type) {
          case "localStorage":
            return Storage.prototype.setItem = function(key, value) {
              if (this === window.localStorage) {
                return log("local storage called");
              } else {
                return _setItem.apply(this, arguments);
              }
            };
        }
      }
    });
    Model = Nimbus.Model = Class.create();
    Model.extend(Events);
    Model.extend({
      service_setup: function(model) {
        var atts;
        log("service setup model", model);
        atts = model.attributes;
        switch (Nimbus.Auth.service) {
          case "Dropbox":
            log("extend as Dropbox");
            model.extend(Nimbus.Model.general_sync);
            model.extend(Nimbus.Model.Dropbox);
            atts.push("synced");
            atts.push("time");
            model.attributes = atts;
            break;
          case "GDrive":
            log("extend as GDrive");
            model.extend(Nimbus.Model.general_sync);
            model.extend(Nimbus.Model.Realtime);
            atts.push("gid");
            atts.push("synced");
            atts.push("time");
            atts.push("type");
            model.attributes = atts;
            window.model_initialize(model);
            break;
          default:
            log("Invalid service name");
        }
        return model;
      },
      setup: function(name, atts) {
        var Deletion, model;
        log("model setup");
        model = Model.sub();
        if (name) {
          model.name = name;
        }
        if (atts) {
          model.attributes = atts;
        }
        model.extend(Nimbus.Model.Local);
        if ((Nimbus.Auth.service != null) || (Nimbus.Auth.sync_services != null) || name === "binary" || name === "binary_Deletion") {
          log("model 1", model);
          if (name.indexOf("_Deletion") < 0) {
            model = this.service_setup(model);
          }
        } else {
          log("name:", name);
          log("Please setup Nimbus.Auth first before creating models");
        }
        if (name.indexOf("_Deletion") < 0) {
          Deletion = Nimbus.Model.setup(name + "_" + "Deletion", ["deletion_id", "listid"]);
          Deletion.extend(Nimbus.Model.Local);
          Deletion.fetch();
          model.DeletionStorage = Deletion;
        }
        log(model);
        model.fetch();
        if (name.indexOf("_Deletion") < 0) {
          Nimbus.dictModel[name] = model;
        }
        return model;
      },
      created: function(sub) {
        this.records = {};
        return this.attributes = (this.attributes ? makeArray(this.attributes) : []);
      },
      find: function(id) {
        var record;
        record = this.records[id];
        if (!record) {
          throw "Unknown record";
        }
        return record.clone();
      },
      exists: function(id) {
        var e;
        try {
          return this.find(id);
        } catch (_error) {
          e = _error;
          return false;
        }
      },
      refresh: function(values) {
        var i, il, record;
        values = this.fromJSON(values);
        this.records = {};
        i = 0;
        il = values.length;
        while (i < il) {
          record = values[i];
          record.newRecord = false;
          this.records[record.id] = record;
          i++;
        }
        this.trigger("refresh");
        return this;
      },
      select: function(callback) {
        var key, result;
        result = [];
        for (key in this.records) {
          if (callback(this.records[key])) {
            result.push(this.records[key]);
          }
        }
        return this.cloneArray(result);
      },
      findByAttribute: function(name, value) {
        var key;
        for (key in this.records) {
          if (this.records[key][name] === value) {
            return this.records[key].clone();
          }
        }
      },
      findAllByAttribute: function(name, value) {
        return this.select(function(item) {
          return item[name] === value;
        });
      },
      each: function(callback) {
        var key, _results;
        _results = [];
        for (key in this.records) {
          _results.push(callback(this.records[key]));
        }
        return _results;
      },
      all: function() {
        return this.cloneArray(this.recordsValues());
      },
      first: function() {
        var record;
        record = this.recordsValues()[0];
        return record && record.clone();
      },
      last: function() {
        var record, values;
        values = this.recordsValues();
        record = values[values.length - 1];
        return record && record.clone();
      },
      count: function() {
        return this.recordsValues().length;
      },
      deleteAll: function() {
        var key, _results;
        _results = [];
        for (key in this.records) {
          _results.push(delete this.records[key]);
        }
        return _results;
      },
      destroyAll: function() {
        var key, _results;
        _results = [];
        for (key in this.records) {
          _results.push(this.records[key].destroy());
        }
        return _results;
      },
      update: function(id, atts) {
        return this.find(id).updateAttributes(atts);
      },
      create: function(atts) {
        var record;
        record = this.init(atts);
        return record.save();
      },
      destroy: function(id) {
        return this.find(id).destroy();
      },
      sync: function(callback) {
        return this.bind("change", callback);
      },
      fetch: function(callbackOrParams) {
        if (typeof callbackOrParams === "function") {
          return this.bind("fetch", callbackOrParams);
        } else {
          return this.trigger.apply(this, ["fetch"].concat(makeArray(arguments)));
        }
      },
      toJSON: function() {
        return this.recordsValues();
      },
      fromJSON: function(objects) {
        var i, results;
        if (!objects) {
          return;
        }
        if (typeof objects === "string") {
          objects = JSON.parse(objects);
        }
        if (isArray(objects)) {
          results = [];
          i = 0;
          while (i < objects.length) {
            results.push(this.init(objects[i]));
            i++;
          }
          return results;
        } else {
          return this.init(objects);
        }
      },
      recordsValues: function() {
        var key, result;
        result = [];
        for (key in this.records) {
          result.push(this.records[key]);
        }
        return result;
      },
      cloneArray: function(array) {
        var i, result;
        result = [];
        i = 0;
        while (i < array.length) {
          result.push(array[i].clone());
          i++;
        }
        return result;
      }
    });
    return Model.include({
      model: true,
      newRecord: true,
      init: function(atts) {
        if (atts) {
          this.load(atts);
        }
        return this.trigger("init", this);
      },
      isNew: function() {
        return this.newRecord;
      },
      isValid: function() {
        return !this.validate();
      },
      validate: function() {},
      load: function(atts) {
        var name, _results;
        _results = [];
        for (name in atts) {
          _results.push(this[name] = atts[name]);
        }
        return _results;
      },
      attributes: function() {
        var attr, i, result;
        result = {};
        i = 0;
        while (i < this.parent.attributes.length) {
          attr = this.parent.attributes[i];
          result[attr] = this[attr];
          i++;
        }
        result.id = this.id;
        return result;
      },
      eql: function(rec) {
        return rec && rec.id === this.id && rec.parent === this.parent;
      },
      save: function() {
        var error;
        error = this.validate();
        if (error) {
          this.trigger("error", this, error);
          return false;
        }
        this.trigger("beforeSave", this);
        if (this.newRecord) {
          this.create();
        } else {
          this.update();
        }
        this.trigger("save", this);
        return this;
      },
      updateAttribute: function(name, value) {
        this[name] = value;
        return this.save();
      },
      updateAttributes: function(atts) {
        this.load(atts);
        return this.save();
      },
      destroy: function() {
        this.trigger("beforeDestroy", this);
        delete this.parent.records[this.id];
        this.destroyed = true;
        this.trigger("destroy", this);
        return this.trigger("change", this, "destroy");
      },
      dup: function() {
        var result;
        result = this.parent.init(this.attributes());
        result.newRecord = this.newRecord;
        return result;
      },
      clone: function() {
        return Object.create(this);
      },
      reload: function() {
        var original;
        if (this.newRecord) {
          return this;
        }
        original = this.parent.find(this.id);
        this.load(original.attributes());
        return original;
      },
      toJSON: function() {
        return this.attributes();
      },
      exists: function() {
        return this.id && this.id in this.parent.records;
      },
      update: function() {
        var clone, records;
        this.trigger("beforeUpdate", this);
        records = this.parent.records;
        records[this.id].load(this.attributes());
        clone = records[this.id].clone();
        this.trigger("update", clone);
        return this.trigger("change", clone, "update");
      },
      create: function() {
        var clone, records;
        this.trigger("beforeCreate", this);
        if (!this.id) {
          this.id = Nimbus.guid();
        }
        this.newRecord = false;
        records = this.parent.records;
        records[this.id] = this.dup();
        clone = records[this.id].clone();
        this.trigger("create", clone);
        return this.trigger("change", clone, "create");
      },
      bind: function(events, callback) {
        return this.parent.bind(events, this.proxy(function(record) {
          if (record && this.eql(record)) {
            return callback.apply(this, arguments);
          }
        }));
      },
      trigger: function() {
        return this.parent.trigger.apply(this.parent, arguments);
      }
    });
  })();

  Set = (function() {
    function Set(set) {
      this._set = (set === void 0 ? [] : set);
      this.length = this._set.length;
      this.contains = function(element) {
        return this._set.indexOf(element) !== -1;
      };
    }

    Set.prototype.union = function(s) {
      var A, B, i, set;
      A = (s.length > this.length ? s : this);
      B = (s.length > this.length ? this : s);
      set = A.copy();
      i = 0;
      while (i < B.length) {
        set.add(B._set[i]);
        i++;
      }
      return set;
    };

    Set.prototype.intersection = function(s) {
      var A, B, element, i, set;
      set = new Set();
      A = (s.length > this.length ? s : this);
      B = (s.length > this.length ? this : s);
      i = 0;
      while (i < B.length) {
        element = B._set[i];
        if (A.contains(element)) {
          set.add(element);
        }
        i++;
      }
      return set;
    };

    Set.prototype.difference = function(s) {
      var element, i, set;
      set = new Set();
      i = 0;
      while (i < this.length) {
        element = this._set[i];
        if (!s.contains(element)) {
          set.add(element);
        }
        i++;
      }
      return set;
    };

    Set.prototype.symmetricDifference = function(s) {
      return this.union(s).difference(this.intersection(s));
    };

    Set.prototype.isSuperSet = function(s) {
      var i;
      i = 0;
      while (i < s.length) {
        if (!this.contains(s._set[i])) {
          return false;
        }
        i++;
      }
      return true;
    };

    Set.prototype.isSubSet = function(s) {
      var i;
      i = 0;
      while (i < this.length) {
        if (!s.contains(this._set[i])) {
          return false;
        }
        i++;
      }
      return true;
    };

    Set.prototype.add = function(element) {
      if (this._set.indexOf(element) === -1) {
        this._set.push(element);
        this.length++;
      }
      return this.length;
    };

    Set.prototype.remove = function(element) {
      var i;
      i = this._set.indexOf(element);
      if (i !== -1) {
        this.length--;
        return this._set.splice(i, 1)[0];
      } else {
        return null;
      }
    };

    Set.prototype.copy = function() {
      return new Set(this._set.slice());
    };

    Set.prototype.asArray = function() {
      return this._set;
    };

    return Set;

  })();

  exports = this;

  exports.Set = Set;

  DelayedOp = (function() {
    function DelayedOp(callback) {
      this.callback = callback;
      this.ready = __bind(this.ready, this);
      this.ok = __bind(this.ok, this);
      this.wait = __bind(this.wait, this);
      this.count = 1;
    }

    DelayedOp.prototype.wait = function() {
      return this.count++;
    };

    DelayedOp.prototype.ok = function() {
      if (!--this.count) {
        return this.callback();
      }
    };

    DelayedOp.prototype.ready = function() {
      return this.ok();
    };

    return DelayedOp;

  })();

  OneOp = (function() {
    function OneOp() {
      this.execute_callback = __bind(this.execute_callback, this);
      this.add_last_call = __bind(this.add_last_call, this);
      this.add_call = __bind(this.add_call, this);
      this.running = false;
      this.callbacks = [];
    }

    OneOp.prototype.add_call = function(callback) {
      this.running = true;
      return this.callbacks.push(callback);
    };

    OneOp.prototype.add_last_call = function(callback) {
      return this.last_callback = callback;
    };

    OneOp.prototype.execute_callback = function() {
      var func, _i, _len, _ref;
      _ref = this.callbacks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        func = _ref[_i];
        func();
      }
      this.callbacks = [];
      if (this.last_callback != null) {
        this.last_callback();
      }
      return this.running = false;
    };

    return OneOp;

  })();

  DelayedSyncAnimation = (function() {
    function DelayedSyncAnimation() {
      this.ready = __bind(this.ready, this);
      this.ok = __bind(this.ok, this);
      this.wait = __bind(this.wait, this);
      this.count = 1;
    }

    DelayedSyncAnimation.prototype.wait = function() {
      return this.count++;
    };

    DelayedSyncAnimation.prototype.ok = function() {
      if (!--this.count) {
        return log("ok executed");
      }
    };

    DelayedSyncAnimation.prototype.ready = function() {
      return this.ok();
    };

    return DelayedSyncAnimation;

  })();

  exports = this;

  exports.DelayedOp = DelayedOp;

  exports.OneOp = OneOp;

  exports.DelayedSyncAnimation = DelayedSyncAnimation;

  window.debug = false;

  window.log = function() {
    var stuff;
    stuff = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (window.debug) {
      return console.log(stuff);
    }
  };

  window.one_time_sync = false;

  window.keys = function(item) {
    var key, keys, value;
    keys = [];
    for (key in item) {
      value = item[key];
      keys.push(key);
    }
    return keys;
  };

  Nimbus.Model.general_sync = {
    cloudcache: {},
    create_object_dictionary: function() {
      var dict, obj, _i, _len, _ref;
      dict = {};
      log("object:", this);
      _ref = this.all();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        dict[obj.id] = obj;
      }
      return dict;
    },
    sync_model_base_algo: function() {
      var cloud, cloud_set, cloud_time, d_array, deleted_set, dlist, eq, id, local, local_item, local_set, local_time, utc, utl, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
      log("#ONE TIME SYNC ALGO RUNNING", this.name);
      window.one_time_sync = true;
      window.currently_syncing = true;
      local = this.create_object_dictionary();
      cloud = this.cloudcache;
      local_set = new Set(keys(local));
      cloud_set = new Set(keys(cloud));
      log("local_set", local_set);
      log("cloud_set", cloud_set);
      d_array = [];
      _ref = this.DeletionStorage.all();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dlist = _ref[_i];
        this.delete_from_cloud(dlist.id);
        d_array.push(dlist.id);
        dlist.destroy();
      }
      deleted_set = new Set(d_array);
      log("deleted set", deleted_set);
      log("#the set of ids that are there locally but not there on the cloud", local_set.difference(cloud_set)._set);
      _ref1 = (local_set.difference(cloud_set)._set);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        id = _ref1[_j];
        local_item = local[id];
        if ((local_item["synced"] != null) && local_item.synced) {
          log("id for deletion", id);
          local[id].destroy();
        } else {
          this.add_to_cloud(local_item);
        }
      }
      log("#the set of ids that are there on the cloud but not there locally minus deletions", cloud_set.difference(local_set).difference(deleted_set)._set);
      _ref2 = (cloud_set.difference(local_set).difference(deleted_set)._set);
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        id = _ref2[_k];
        this.add_from_cloud(id);
      }
      log("#the set of ids that are there in the cloud and locally", cloud_set.intersection(local_set)._set);
      utc = [];
      utl = [];
      eq = [];
      _ref3 = (cloud_set.intersection(local_set)._set);
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        id = _ref3[_l];
        local_time = new Date(local[id].time);
        cloud_time = new Date(cloud[id].time);
        log("local_time", local_time.toString());
        log("cloud_time", cloud_time.toString());
        if (local_time - cloud_time === 0) {
          log("equal time stamp do nothin", cloud[id].title);
          eq.push(id);
        } else if (local_time - cloud_time > 0) {
          this.update_to_cloud(local[id]);
          utc.push(id);
        } else {
          this.update_to_local(local[id]);
          utl.push(id);
        }
      }
      window.currently_syncing = false;
      window.one_time_sync = false;
      log("updated to cloud", utc.length, utc);
      log("updated to local", utl.length, utl);
      return log("equal timestamp", eq.length, eq);
    },
    real_time_sync: function(record, method, e) {
      var d, syncable;
      log("method", method);
      this.saveLocal(record,method);
      if (window.currently_syncing) {
        return true;
      } else {
        if (method === "update") {
          this.records[record.id].time = new Date().toString();
        }
      }
      syncable = navigator.onLine && (localStorage["state"] === "Working" || Nimbus.Client.GDrive.check_auth());
      if (!syncable) {
        console.log("syncing is not setup correctly or the instance is not online");
        return true;
      }
      switch (method) {
        case "destroy":
          if (record.synced) {
            if (syncable) {
              log("deletion in cloud");
              return this.delete_from_cloud(record.id);
            } else {
              d = Deletion.init({
                id: record.id
              });
              return d.save();
            }
          }
          break;
        case "create":
          this.add_to_cloud(record, function() {});
          return
        case "update":
          return this.update_to_cloud(record, function() {});
        case "read":
          return this.update_to_local(record, function() {});
        default:
          return log("REAL TIME SYNCING FAILED, THIS METHOD NOT IMPLEMENTED");
      }
    },
    delta_update: function() {
      var change;
      return change = this.get_delta;
    }
  };

  Nimbus.Model.Local = {
    indexedDB : null,
    extended: function() {
      if (Nimbus.Auth.app_name) {
        window._indexdb = new PouchDB(Nimbus.Auth.app_name);
      };
      this.sync(this.proxy(this.saveLocal));
      return this.fetch(this.proxy(this.loadLocal));
    },
    saveLocal: function(record,method) {
      var result = JSON.stringify(this);
      if(!window._indexdb && Nimbus.Auth.app_name){
        window._indexdb = new PouchDB(Nimbus.Auth.app_name);
      }
      if (!window._indexdb) {
        localStorage[this.name] = result;
      }else{
        var db = window._indexdb,tx,store,self=this,_data;
        // if ((this.batch_mode && this.on_batch_save) || !this.batch_mode) {
        if (record) {
          // save single
          _data = {
            _id:record.id,
            type : this.name,
            data :JSON.stringify(record)
          }
          db.get(record.id,function(err,res){
            if (!err) {
              db.remove(res,function(e,r){
                if (method == 'destroy') {
                  return;
                };
                db.put(_data);
              })
            }else{
              db.put(_data);
            }
          });
        }else{
          // loop save all
          var key;
          for(key in this.records){
            _data = {
              _id: key,
              type : this.name,
              data : JSON.stringify(this.records[key])
            };
            db.get(key,function(err,res){
              if (!err) {
                _data._rev = res._rev
              }
              db.put(_data);
            });
          }
        };
      };
    },
    loadLocal: function() {
      var indexedDB, req, result, self;
      if(!window._indexdb && Nimbus.Auth.app_name){
        window._indexdb = new PouchDB(Nimbus.Auth.app_name);
      }
      if (!window._indexdb) {
        result = localStorage[this.name];
        if (!result) {
          return;
        }
        result = JSON.parse(result);
        this.refresh(result);
        return;
      }else{
        var self = this,
            db = window._indexdb;
      
        db.allDocs({include_docs: true}, function(err, response) { 
          if (!err) {
            var rows = response.rows,result=[],doc;
            for (key in rows){
              doc = rows[key].doc
              if (doc['type'] === self.name) {
                result.push(JSON.parse(doc.data));
              };
            }
            self.refresh(result);
          }
        });
      }
    }
  };

  Nimbus.Model.Dropbox = {
    cloudcache: {},
    last_hash: "",
    hash: "",
    toCloudStructure: function(object) {
      log("local to cloud structure");
      return JSON.stringify(object);
    },
    fromCloudStructure: function(value) {
      log("changes cloud to local data in the form a dictionary");
      return value;
    },
    diff_objects: function(previous, current) {
      var diff, f, v;
      diff = {};
      for (f in previous) {
        v = previous[f];
        if (current[f] !== previous[f]) {
          diff[f] = [current[f], previous[f]];
        }
      }
      if ((previous["parent_id"] != null) !== (current["parent_id"] != null)) {
        diff["parent_id"] = ["one of them is null"];
      }
      return diff;
    },
    add_to_cloud: function(object, callback) {
      log("add to cloud", object.name);
      return Nimbus.Client.Dropbox.putFileContents(("/" + Nimbus.Auth.app_name) + ("/" + this.name + "/" + object.id + ".txt"), this.toCloudStructure(object), function(resp) {
        log(object.name, "finished being added to cloud");
        log("resp", resp);
        window.currently_syncing = true;
        object.time = resp.modified;
        object.synced = true;
        object.save();
        window.currently_syncing = false;
        if (callback != null) {
          return callback(resp);
        }
      });
    },
    delete_from_cloud: function(object_id, callback) {
      log("delete from cloud", object_id);
      log("delete route", ("/" + Nimbus.Auth.app_name) + ("/" + this.name + "/" + object_id + ".txt"));
      return Nimbus.Client.Dropbox.deletePath(("/" + Nimbus.Auth.app_name) + ("/" + this.name + "/" + object_id + ".txt"), function() {
        log("finished delete from cloud", object_id);
        if (callback != null) {
          return callback();
        }
      });
    },
    update_to_cloud: function(object, callback) {
      log("updated to cloud", object.name);
      return Nimbus.Client.Dropbox.putFileContents(("/" + Nimbus.Auth.app_name) + ("/" + this.name + "/" + object.id + ".txt"), this.toCloudStructure(object), function(resp) {
        log(object.name, "finished being updated to cloud");
        window.currently_syncing = true;
        object.time = resp.modified;
        object.synced = true;
        object.save();
        window.currently_syncing = false;
        if (callback != null) {
          return callback(resp);
        }
      });
    },
    add_from_cloud: function(object_id, callback) {
      var _this = this;
      log("add from cloud", object_id);
      return Nimbus.Client.Dropbox.getFileContents(("/" + Nimbus.Auth.app_name) + ("/" + this.name + "/" + object_id + ".txt"), function(data) {
        var converted, x;
        log("cloud read data", data);
        window.currently_syncing = true;
        converted = _this.fromCloudStructure(data);
        x = _this.init(converted);
        x.synced = true;
        x.time = _this.cloudcache[object_id].time;
        x.save();
        window.currently_syncing = false;
        if (callback != null) {
          return callback(data);
        }
      });
    },
    update_to_local: function(object, callback) {
      var _this = this;
      log("update to local", object.name);
      return Nimbus.Client.Dropbox.getFileContents(("/" + Nimbus.Auth.app_name) + ("/" + this.name + "/" + object.id + ".txt"), function(data) {
        var converted, x;
        log("cloud read data", data);
        window.currently_syncing = true;
        converted = _this.fromCloudStructure(data);
        x = _this.find(object.id);
        converted.time = _this.cloudcache[object.id].time;
        x.updateAttributes(converted);
        return window.currently_syncing = false;
      });
    },
    sync_all: function(cb) {
      var _this = this;
      log("syncs all the data, normally happens at the start of a program or coming back from offline");
      window.current_syncing = new DelayedOp(function() {
        log("call back sync called");
        window.current_syncing = new DelayedOp(function() {
          window.current_syncing = null;
          if (cb != null) {
            return cb();
          }
        });
        _this.sync_model_base_algo();
        return window.current_syncing.ready();
      });
      this.load_all_from_cloud();
      return window.current_syncing.ready();
    },
    load_all_from_cloud: function() {
      var error,
        _this = this;
      log("loads all the data from the cloud locally, probably not feasible with dropbox and changes need to happen");
      this.cloudcache = {};
      try {
        return Nimbus.Client.Dropbox.getMetadataList("/" + Nimbus.Auth.app_name + "/" + this.name, function(data) {
          var id, title, x, _i, _len, _ref, _results;
          log("call back load called");
          log("data", data);
          _ref = data.contents;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            x = _ref[_i];
            title = x.path;
            id = title.replace(("/" + Nimbus.Auth.app_name + "/") + ("" + _this.name + "/"), "").replace(".txt", "");
            _results.push(_this.cloudcache[id] = {
              id: id,
              time: x.modified
            });
          }
          return _results;
        }, function(error) {
          console.log("ERROR: error called for metadataList, folder should be created");
          Nimbus.Client.Dropbox.createFolder("/" + Nimbus.Auth.app_name + "/" + _this.name, function(data) {
            return log("call back create folder called", data);
          });
          return _this.cloudcache = {};
        });
      } catch (_error) {
        error = _error;
        return log("trying to get the folder failed, probably cuz it don't exist", error);
      }
    },
    get_delta: function() {
      return log("get the delta for ", this.name, " since last synced");
    },
    extended: function() {
      this.sync(this.proxy(this.real_time_sync));
      return this.fetch(this.proxy(this.loadLocal));
    }
  };

  Nimbus.Auth.Dropbox_auth = {
    authenticate_dropbox: function() {
      localStorage["key"] = this.key;
      localStorage["secret"] = this.secret;
      localStorage["state"] = "Auth";
      return Nimbus.Client.Dropbox.get_request_token(this.key, this.secret, Nimbus.Client.Dropbox.authorize_token);
    },
    initialize_dropbox: function() {
      log("initialization called");
      if (location.protocol === "chrome-extension:") {
        log("Chrome edition authentication");
        chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
          if (tab.title === "API Request Authorized") {
            chrome.tabs.remove(tabId);
            return Nimbus.Client.Dropbox.get_access_token(function(data) {
              localStorage["state"] = "Working";
              if (Nimbus.Auth.authorized_callback != null) {
                Nimbus.Auth.authorized_callback();
              }
              Nimbus.Auth.app_ready_func();
              console.log("NimbusBase is working! Chrome edition.");
              return Nimbus.track.registered_user();
            });
          }
        });
      }
      if ((localStorage["state"] != null) && localStorage["state"] === "Auth") {
        return Nimbus.Client.Dropbox.get_access_token(function(data) {
          localStorage["state"] = "Working";
          if (Nimbus.Auth.authorized_callback != null) {
            Nimbus.Auth.authorized_callback();
          }
          Nimbus.Auth.app_ready_func();
          console.log("NimbusBase is working!");
          return Nimbus.track.registered_user();
        });
      } else {
        return Nimbus.Auth.app_ready_func();
      }
    },
    dropbox_authorized: function() {
      if (Nimbus.Auth.service === "Dropbox") {
        if (localStorage["state"] === "Working") {
          return true;
        } else {
          return false;
        }
      } else {
        return false;
      }
    },
    logout_dropbox: function(callback) {
      var k, v, _ref;
      localStorage.clear();
      if (Nimbus.dictModel != null) {
        _ref = Nimbus.dictModel;
        for (k in _ref) {
          v = _ref[k];
          v.records = {};
        }
      }
      if (this.sync_services != null) {
        Nimbus.Auth.setup(this.sync_services);
      }
      if (callback != null) {
        return callback();
      }
    }
  };

  REALTIME_MIMETYPE = 'application/vnd.google-apps.drive-sdk';

  window.app_id = "762177952485";

  Nimbus.Model.Realtime = {
    cloudcache: {},
    toCloudStructure: function(object) {
      log("local to cloud structure");
      object["type"] = this.name;
      return JSON.stringify(object);
    },
    fromCloudStructure: function(value) {
      log("changes cloud to local data in the form a dictionary");
      return JSON.parse(value);
    },
    diff_objects: function(previous, current) {
      var diff, f, v;
      diff = {};
      for (f in previous) {
        v = previous[f];
        if (current[f] !== previous[f]) {
          diff[f] = [current[f], previous[f]];
        }
      }
      if ((previous["parent_id"] != null) !== (current["parent_id"] != null)) {
        diff["parent_id"] = ["one of them is null"];
      }
      return diff;
    },
    add_to_cloud: function(object, callback) {
      var content;
      log("add to cloud", object);
      window.currently_syncing = true;
      object.time = new Date().toString();
      object.type = this.name;
      object.synced = true;
      object.save();
      window.currently_syncing = false;
      content = this.toCloudStructure(object);
      return window.todo.set(object.id, content);
    },
    delete_from_cloud: function(object_id, callback) {
      log("delete from cloud", object_id, window.todo.has(object_id));
      if (window.todo.has(object_id)) {
        return window.todo["delete"](object_id);
      }
    },
    update_to_cloud: function(object, callback) {
      var content;
      log("updated to cloud", object.id);
      content = this.toCloudStructure(object);
      return window.todo.set(object.id, content);
    },
    add_from_cloud: function(object_id, callback) {
      var converted, data, x;
      log("add from cloud GDrive", object_id);
      data = window.todo.get(object_id);
      window.currently_syncing = true;
      converted = this.fromCloudStructure(data);
      x = this.init(converted);
      x.synced = true;
      x.save();
      return window.currently_syncing = false;
    },
    update_to_local: function(object, callback) {
      var converted, data, x;
      log("update to local", object);
      data = window.todo.get(object.id);
      window.currently_syncing = true;
      converted = this.fromCloudStructure(data);
      x = this.init(converted);
      x.synced = true;
      x.save();
      return window.currently_syncing = false;
    },
    sync_all: function(cb) {
      var _this = this;
      log("syncs all the data, normally happens at the start of a program or coming back from offline");
      this.load_all_from_cloud();
      this.sync_model_base_algo();
      window.current_syncing = new DelayedOp(function() {
        log("call back sync called");
        window.current_syncing = new DelayedOp(function() {
          window.current_syncing = null;
          if (cb != null) {
            return cb();
          }
        });
        _this.sync_model_base_algo();
        return window.current_syncing.ready();
      });
      this.load_all_from_cloud();
      return window.current_syncing.ready();
    },
    load_all_from_cloud: function() {
      var content, x, _i, _len, _ref, _results;
      log("loads all the data from the cloud locally");
      this.cloudcache = {};
      _ref = window.todo.keys();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        content = this.fromCloudStructure(window.todo.get(x));
        if (content.type === this.name) {
          _results.push(this.cloudcache[x] = content);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    get_delta: function() {
      return log("get the delta for ", this.name, " since last synced");
    },
    extended: function() {
      this.sync(this.proxy(this.real_time_sync));
      return this.fetch(this.proxy(this.loadLocal));
    }
  };

  /* initialization and model linking code*/


  window.initializeModel = function(model) {
    var field;
    log("model initialization", model);
    field = model.createMap({});
    return model.getRoot().set("todo", field);
  };

  window.onFileLoaded = function(doc) {
    var process_event, todo;
    log("file loaded", doc);
    window.doc = doc;
    process_event = function(event) {
      var a, current_event, model, obj;
      log("PROCESS EVENT");
      log(event);
      current_event = "NONE";
      if (event.oldValue != null) {
        obj = JSON.parse(event.oldValue);
      }
      if (event.newValue != null) {
        obj = JSON.parse(event.newValue);
      }
      log("object", obj);
      window.obj = obj;
      model = Nimbus.dictModel[obj.type];
      if (event.oldValue === null) {
        log("add event");
        model.add_from_cloud(obj.id);
        current_event = "CREATE";
      } else if (event.newValue === null) {
        log("delete event");
        window.currently_syncing = true;
        if (model.exists(obj.id)) {
          a = model.find(obj.id);
          a.destroy();
        }
        window.currently_syncing = false;
        current_event = "DELETE";
      } else {
        log("changing the data inside a entry event");
        model.update_to_local(obj);
        current_event = "UPDATE";
      }
      log("EVENT: ", current_event, " OBJ: ", obj);
      if (window.realtime_update_handler != null) {
        return window.realtime_update_handler(current_event, obj, event.isLocal);
      }
    };
    todo = doc.getModel().getRoot().get("todo");
    window.todo = todo;
    if (window.real_time_callback != null) {
      window.real_time_callback();
    }
    return todo.addEventListener(gapi.drive.realtime.EventType.VALUE_CHANGED, process_event);
  };

  window.create_share_client = function() {
    var share_client;
    share_client = new gapi.drive.share.ShareClient(window.app_id);
    share_client.setItemIds(c_file.id);
    share_client.showSettingsDialog();
    return window.share_client = share_client;
  };

  window.handleErrors = handleErrors = function(e) {
    if (e.type === gapi.drive.realtime.ErrorType.TOKEN_REFRESH_REQUIRED) {
      return authorizer.authorize();
    } else if (e.type === gapi.drive.realtime.ErrorType.CLIENT_ERROR) {
      return alert("An Error happened: " + e.message);
    } else if (e.type === gapi.drive.realtime.ErrorType.NOT_FOUND) {
      return alert("The file was not found. It does not exist or you do not have read access to the file.");
    }
  };

  window.startRealtime = function(callback) {
    if (callback != null) {
      window.real_time_callback = callback;
    }
    return gapi.load("auth:client,drive-realtime,drive-share", function() {
      log("gapi for everything loaded");
      return Nimbus.Client.GDrive.getMetadataList("title = '" + Nimbus.Auth.app_name + "'", function(data) {
        var c_file, i, x, _i, _len, _ref;
        console.log("drive apps", data);
        window.app_files = data.items;
        i = [];
        _ref = data.items;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          x = _ref[_i];
          log(x.mimeType);
          if (x.mimeType.indexOf("application/vnd.google-apps.drive-sdk") >= 0) {
            i.push(x);
          }
        }
        log("index", i);
        if (i.length > 0) {
          log("file there");
          c_file = i[0];
          window.c_file = c_file;
          return gapi.drive.realtime.load(c_file.id, onFileLoaded, initializeModel, handleErrors);
        } else {
          log("file not there");
          Nimbus.Client.GDrive.insertFile("", Nimbus.Auth.app_name, 'application/vnd.google-apps.drive-sdk', null, function(data) {
            log("finished insertFile", data);
            window.c_file = data;
            return gapi.drive.realtime.load(data.id, onFileLoaded, initializeModel, handleErrors);
          });
          return log("need to create file for app");
        }
      });
    });
  };

  window.load_new_file = function(file_id, callback, exception_handle) {
    if (callback != null) {
      window.real_time_callback = callback;
    }
    return Nimbus.Share.getFile(file_id, function(data) {
      window.c_file = data;
      if (!data.id) {
        return;
      }
      if (exception_handle && exception_handle instanceof Function) {
        return gapi.drive.realtime.load(file_id, onFileLoaded, initializeModel, exception_handle);
      } else {
        return gapi.drive.realtime.load(file_id, onFileLoaded, initializeModel, handleErrors);
      }
    });
  };

  Nimbus.Client.Dropbox = {
    get_request_token: function(key, secret, callback) {
      var header, xhr;
      xhr = new XMLHttpRequest();
      xhr.open("POST", "https://api.dropbox.com/1/oauth/request_token", true);
      header = 'OAuth oauth_version="1.0",oauth_signature_method="PLAINTEXT",oauth_consumer_key="' + key + '",oauth_signature="' + secret + '&"';
      log(header);
      xhr.setRequestHeader("Authorization", header);
      xhr.onreadystatechange = function() {
        var data, i, k, pair, pairs, request_token, result, v, _i, _len;
        if (this.readyState === 4) {
          if (this.status === 200) {
            data = this.response;
            log(data);
            pairs = data.split(/&/);
            request_token = {};
            for (_i = 0, _len = pairs.length; _i < _len; _i++) {
              i = pairs[_i];
              pair = i.split(RegExp("="), 2);
              request_token[pair[0]] = pair[1];
            }
            log("Token result", request_token);
            for (k in request_token) {
              v = request_token[k];
              localStorage[k] = v;
            }
            window.request_token = request_token;
            if (callback != null) {
              return callback(request_token);
            }
          } else {
            try {
              result = JSON.parse(result);
            } catch (_error) {}
            return error(result, this.status, this);
          }
        }
      };
      return xhr.send();
    },
    authorize_token: function(request_token) {
      var auth_url, ref, return_url;
      log("authorize url", document.URL);
      if (document.URL.slice(0, 4) === "file" && (typeof cordova !== "undefined" && cordova !== null)) {
        log("Phonegap login");
        auth_url = "https://www.dropbox.com/1/oauth/authorize?oauth_token=" + request_token.oauth_token;
        ref = window.open(auth_url, '_blank', 'location=yes');
        window.ref = ref;
        window.auth_count = 0;
        ref.addEventListener('loadstop', function(event) {
          console.log(event);
          console.log("event", event.url.indexOf("https://www.dropbox.com/1/oauth/authorize"));
          if (event.url.indexOf("https://www.dropbox.com/1/oauth/authorize") >= 0) {
            window.auth_count = window.auth_count + 1;
            if (window.auth_count === 2) {
              Nimbus.Auth.Dropbox_auth.initialize_dropbox();
              return window.ref.close();
            }
          }
        });
        return ref.addEventListener('exit', function(event) {
          return Nimbus.Auth.logout_dropbox();
        });
      } else if (document.URL.slice(0, 4) === "http") {
        return_url = "&oauth_callback=" + encodeURIComponent(document.URL);
        auth_url = "https://www.dropbox.com/1/oauth/authorize?oauth_token=" + request_token.oauth_token + return_url;
        return location.replace(auth_url);
      } else if (document.URL.slice(0, 6) === "chrome") {
        log("chrome app!");
        auth_url = "https://www.dropbox.com/1/oauth/authorize?oauth_token=" + request_token.oauth_token;
        return chrome.tabs.create({
          "url": auth_url,
          "selected": true
        }, function(tab) {
          return log("tab created", tab.id);
        });
      } else {
        auth_url = "https://www.dropbox.com/1/oauth/authorize?oauth_token=" + request_token.oauth_token;
        return location.replace(auth_url);
      }
    },
    get_access_token: function(callback) {
      var auth_string, oauth_token, oauth_token_secret, xhr;
      oauth_token = localStorage["oauth_token"];
      oauth_token_secret = localStorage["oauth_token_secret"];
      auth_string = 'OAuth oauth_version="1.0",oauth_signature_method="PLAINTEXT",oauth_consumer_key="' + Nimbus.Auth.key + '",oauth_token="' + oauth_token + '",oauth_signature="' + Nimbus.Auth.secret + "&" + oauth_token_secret + '"';
      log("auth_string:", auth_string);
      xhr = new XMLHttpRequest();
      xhr.open("POST", "https://api.dropbox.com/1/oauth/access_token", true);
      xhr.setRequestHeader("Authorization", auth_string);
      xhr.onreadystatechange = function() {
        var access_token, data, i, k, pair, pairs, result, v, _i, _len;
        if (this.readyState === 4) {
          if (this.status === 200) {
            data = this.response;
            log(data);
            pairs = data.split(/&/);
            access_token = {};
            for (_i = 0, _len = pairs.length; _i < _len; _i++) {
              i = pairs[_i];
              pair = i.split(RegExp("="), 2);
              access_token[pair[0]] = pair[1];
            }
            log("Access result", access_token);
            for (k in access_token) {
              v = access_token[k];
              localStorage[k] = v;
            }
            window.access_token = access_token;
            if (callback != null) {
              return callback(access_token);
            }
          } else {
            try {
              result = JSON.parse(result);
            } catch (_error) {}
            return log(result, this.status, this);
          }
        }
      };
      return xhr.send();
    },
    send_request: function(method, url, body, success, failure) {
      var auth_string, key, oauth_token, oauth_token_secret, pList, xhr;
      oauth_token = localStorage["oauth_token"];
      oauth_token_secret = localStorage["oauth_token_secret"];
      auth_string = 'OAuth oauth_version="1.0",oauth_signature_method="PLAINTEXT",oauth_consumer_key="' + Nimbus.Auth.key + '",oauth_token="' + oauth_token + '",oauth_signature="' + Nimbus.Auth.secret + "&" + oauth_token_secret + '"';
      log("auth_string:", auth_string);
      xhr = new XMLHttpRequest();
      xhr.open(method, url, true);
      xhr.setRequestHeader("Authorization", auth_string);
      xhr.onreadystatechange = function() {
        var result;
        if (this.readyState === 4) {
          if (this.status === 200) {
            result = this.response;
            try {
              result = JSON.parse(result);
            } catch (_error) {}
            log("REQUEST RESULT", result);
            if (success != null) {
              success(result);
            }
          } else {
            try {
              result = JSON.parse(result);
            } catch (_error) {}
            log(result, this.status, this);
            if (failure != null) {
              failure(result);
            }
          }
          if (window.current_syncing != null) {
            return window.current_syncing.ok();
          }
        }
      };
      if (method === "POST") {
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        if (body) {
          pList = [];
          for (key in body) {
            pList.push(encodeURIComponent(key) + "=" + encodeURIComponent(body[key]));
          }
          body = (pList.length > 0 ? pList.join("&").replace(/%20/g, "+") : null);
        }
        log(body);
      }
      log("send request params", method, url, body, success, failure);
      if (window.current_syncing != null) {
        window.current_syncing.wait();
      }
      xhr.send(body);
      return window.xhr = xhr;
    },
    send_request_without_delay: function(method, url, body, success, failure) {
      var auth_string, key, oauth_token, oauth_token_secret, pList, xhr;
      oauth_token = localStorage["oauth_token"];
      oauth_token_secret = localStorage["oauth_token_secret"];
      auth_string = 'OAuth oauth_version="1.0",oauth_signature_method="PLAINTEXT",oauth_consumer_key="' + Nimbus.Auth.key + '",oauth_token="' + oauth_token + '",oauth_signature="' + Nimbus.Auth.secret + "&" + oauth_token_secret + '"';
      log("auth_string:", auth_string);
      xhr = new XMLHttpRequest();
      xhr.open(method, url, true);
      xhr.setRequestHeader("Authorization", auth_string);
      xhr.onreadystatechange = function() {
        var result;
        if (this.readyState === 4) {
          if (this.status === 200) {
            result = this.response;
            try {
              result = JSON.parse(result);
            } catch (_error) {}
            log("REQUEST RESULT", result);
            if (success != null) {
              return success(result);
            }
          } else {
            try {
              result = JSON.parse(result);
            } catch (_error) {}
            log(result, this.status, this);
            if (failure != null) {
              return failure(result);
            }
          }
        }
      };
      if (method === "POST") {
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        if (body) {
          pList = [];
          for (key in body) {
            pList.push(encodeURIComponent(key) + "=" + encodeURIComponent(body[key]));
          }
          body = (pList.length > 0 ? pList.join("&").replace(/%20/g, "+") : null);
        }
        log(body);
      }
      log("send request params", method, url, body, success, failure);
      return xhr.send(body);
    },
    putFileContents: function(path, content, success, error) {
      log("putFileContents");
      return Nimbus.Client.Dropbox.send_request("PUT", "https://api-content.dropbox.com/1/files_put/sandbox" + path, content, success, error);
    },
    createFolder: function(path, success, error) {
      log("createFolder");
      return Nimbus.Client.Dropbox.send_request("POST", "https://api.dropbox.com/1/fileops/create_folder", {
        root: 'sandbox',
        path: path
      }, success, error);
    },
    deletePath: function(path, success, error) {
      log("deletePath");
      return Nimbus.Client.Dropbox.send_request("POST", "https://api.dropbox.com/1/fileops/delete", {
        root: 'sandbox',
        path: path
      }, success, error);
    },
    getFileContents: function(path, success, error) {
      log("getFileContents");
      return Nimbus.Client.Dropbox.send_request("GET", "https://api-content.dropbox.com/1/files/sandbox" + path, "", success, error);
    },
    getMetadataList: function(path, success, error) {
      log("getMetadataList");
      return Nimbus.Client.Dropbox.send_request("GET", "https://api.dropbox.com/1/metadata/sandbox" + path, "", success, error);
    },
    getAccountInfo: function(success, error) {
      log("getAccountInfo");
      return Nimbus.Client.Dropbox.send_request_without_delay("GET", "https://api.dropbox.com/1/account/info", "", success, error);
    }
  };

  window.client = null;

  Nimbus.Client.Dropbox.Binary = {
    binary_setup: function() {
      return window.binary = Nimbus.Model.setup("binary", ["name", "path", "copied", "directlink", "sharelink", "expiration"]);
    },
    initialize_client: function() {
      log("initializing second client");
      if (Nimbus.Auth.key != null) {
        if (window.client == null) {
          window.client = new Dropbox.Client({
            key: Nimbus.Auth.key,
            secret: Nimbus.Auth.secret,
            sandbox: true
          });
          return window.client.oauth.setToken(localStorage["oauth_token"], localStorage["oauth_token_secret"]);
        } else {

        }
      } else {
        return log("can't upload file with no dropbox credentials");
      }
    },
    upload_blob: function(blob, name, callback) {
      var come_back, new_file;
      log("upload new blob");
      Nimbus.Client.Dropbox.Binary.initialize_client();
      if (window.client != null) {
        new_file = binary.create({
          name: name,
          copied: false
        });
        come_back = function(error, stat) {
          console.log("wrote file to cloud");
          console.log(error, stat);
          new_file.copied = true;
          new_file.path = stat.path;
          new_file.save();
          if (callback != null) {
            return callback(new_file);
          }
        };
        log("file name", name);
        return window.client.writeFile(name, blob, come_back);
      } else {
        return log("client won't initialize");
      }
    },
    upload_file: function(file, callback) {
      var come_back, new_file;
      log("upload new file");
      Nimbus.Client.Dropbox.Binary.initialize_client();
      if (window.client != null) {
        new_file = binary.create({
          name: file.name,
          copied: false
        });
        come_back = function(error, stat) {
          console.log("wrote file to cloud");
          console.log(error, stat);
          new_file.copied = true;
          new_file.path = stat.path;
          new_file.save();
          if (callback != null) {
            return callback(new_file);
          }
        };
        log("file name", file.name);
        return window.client.writeFile(file.name, file, come_back);
      } else {
        return log("client won't initialize");
      }
    },
    read_file: function(binary, callback) {
      var come_back;
      log("read a binary file from the server");
      Nimbus.Client.Dropbox.Binary.initialize_client();
      if (window.client != null) {
        come_back = function(error, data, stat) {
          console.log(error, data, stat);
          return callback(data);
        };
        return window.client.readFile(binary.path, {
          "blob": true
        }, come_back);
      } else {
        return log("client won't initialize");
      }
    },
    share_link: function(binary, callback) {
      var come_back;
      log("get the share link");
      Nimbus.Client.Dropbox.Binary.initialize_client();
      if (window.client != null) {
        come_back = function(error, data) {
          console.log(error, data);
          binary.sharelink = data.url;
          binary.save();
          return callback(data);
        };
        console.log(binary.path);
        return window.client.makeUrl(binary.path, {}, come_back);
      }
    },
    direct_link: function(binary, callback) {
      var come_back;
      log("get the share link");
      Nimbus.Client.Dropbox.Binary.initialize_client();
      if (window.client != null) {
        if ((binary.directlink != null) && new Date(binary.expiration) > new Date()) {
          return callback({
            "url": binary.directlink,
            "expiresAt": binary.expiration
          });
        } else {
          come_back = function(error, url) {
            console.log(error, url);
            binary.directlink = url.url;
            binary.expiration = url.expiresAt.toString();
            binary.save();
            return callback(url);
          };
          return window.client.makeUrl(binary.path, {
            'download': true,
            'downloadHack': true
          }, come_back);
        }
      }
    },
    delete_file: function(binary) {
      var come_back;
      log("delete file");
      Nimbus.Client.Dropbox.Binary.initialize_client();
      if (window.client != null) {
        come_back = function(error, stat) {
          return binary.destroy();
        };
        return window.client.remove(binary.path, come_back);
      } else {
        return log("client won't initialize");
      }
    }
  };

  Nimbus.Client.GDrive = {
    check_auth: function() {
      var token;
      log("checking if this is authenticated");
      if (location.protocol === "chrome-extension:") {
        if ((typeof gapi !== "undefined" && gapi !== null) && (gapi.auth != null) && gapi.auth.getToken() === null) {
          token = Nimbus.Auth.GDrive.getLocalOauth2Token();
          if ((token == null) || Nimbus.Auth.GDrive.isTokenExpires(token)) {
            return false;
          } else {
            gapi.auth.setToken(token);
            return true;
          }
        }
      }
      return (typeof gapi !== "undefined" && gapi !== null) && (gapi.auth != null) && gapi.auth.getToken() !== null && Object.keys(gapi.auth.getToken()).length !== 0;
    },
    authorize: function(client_id, scopes, callback) {
      log("authorized called");
      return gapi.auth.authorize({
        client_id: client_id,
        scope: scopes,
        immediate: false
      }, callback);
    },
    insertFile: function(content, title, contentType, parent, callback) {
      var base64Data, boundary, close_delim, delimiter, metadata, multipartRequestBody, params;
      log("putFileContents");
      boundary = "-------314159265358979323846";
      delimiter = "\r\n--" + boundary + "\r\n";
      close_delim = "\r\n--" + boundary + "--";
      base64Data = btoa(content);
      metadata = {
        title: title,
        mimeType: contentType
      };
      if (parent != null) {
        metadata['parents'] = [
          {
            "kind": "drive#fileLink",
            "id": parent
          }
        ];
      }
      multipartRequestBody = delimiter + "Content-Type: application/json\r\n\r\n" + JSON.stringify(metadata) + delimiter + "Content-Type: " + contentType + "\r\n" + 'Content-Transfer-Encoding: base64\r\n' + "\r\n" + base64Data + close_delim;
      log("MULTI: ", multipartRequestBody);
      if (!callback) {
        callback = function(file) {
          return log("Update Complete ", file);
        };
      }
      params = {
        path: "/upload/drive/v2/files",
        method: "POST",
        params: {
          uploadType: "multipart"
        },
        headers: {
          "Content-Type": "multipart/mixed; boundary=\"" + boundary + "\""
        },
        body: multipartRequestBody
      };
      return this.make_request(params, callback);
    },
    deleteFile: function(file_id, callback) {
      var params,
        _this = this;
      log("deletePath");
      if (!callback) {
        callback = function(resp) {
          var params;
          params = {
            path: "/drive/v2/files/" + file_id,
            method: "DELETE"
          };
          _this.make_request(params, function(data) {
            return log("delete complete", data);
          });
          return log("Delete Complete ", resp);
        };
      }
      params = {
        path: "/drive/v2/files/" + file_id + "/trash",
        method: "POST"
      };
      return this.make_request(params, callback);
    },
    getFile: function(file_id, callback) {
      var params;
      log("getFileContents");
      if (!callback) {
        callback = function(resp) {
          return log("Read Complete ", resp);
        };
      }
      params = {
        path: "/drive/v2/files/" + file_id,
        method: "GET"
      };
      return this.make_request(params, callback);
    },
    readFile: function(url, callback) {
      var accessToken, xhr;
      if (!callback) {
        callback = function(resp) {
          return log("Read Complete ", resp);
        };
      }
      accessToken = gapi.auth.getToken().access_token;
      xhr = new XMLHttpRequest();
      xhr.open("GET", url);
      xhr.setRequestHeader("Authorization", "Bearer " + accessToken);
      xhr.onload = function() {
        callback(xhr.responseText);
        if (window.current_syncing != null) {
          return window.current_syncing.ok();
        }
      };
      xhr.onerror = function() {
        return callback(null);
      };
      if (window.current_syncing != null) {
        window.current_syncing.wait();
      }
      return xhr.send();
    },
    updateFile: function(content, title, contentType, file_id, folder_id, callback) {
      var base64Data, boundary, close_delim, delimiter, metadata, multipartRequestBody, params;
      log("updateFileContents");
      boundary = "-------314159265358979323846";
      delimiter = "\r\n--" + boundary + "\r\n";
      close_delim = "\r\n--" + boundary + "--";
      contentType = "text/html";
      metadata = {
        mimeType: contentType
      };
      base64Data = btoa(content);
      metadata = {
        title: title,
        mimeType: contentType
      };
      multipartRequestBody = delimiter + "Content-Type: application/json\r\n\r\n" + JSON.stringify(metadata) + delimiter + "Content-Type: " + contentType + "\r\n" + 'Content-Transfer-Encoding: base64\r\n' + "\r\n" + base64Data + close_delim;
      if (!callback) {
        callback = function(file) {
          return log("Update Complete ", file);
        };
      }
      params = {
        path: "/upload/drive/v2/files/" + file_id,
        method: "PUT",
        params: {
          fileId: file_id,
          uploadType: "multipart"
        },
        headers: {
          "Content-Type": "multipart/mixed; boundary=\"" + boundary + "\""
        },
        body: multipartRequestBody
      };
      return this.make_request(params, callback);
    },
    getMetadataList: function(query, callback) {
      var params;
      log("getMetadataList");
      if (!callback) {
        callback = function(file) {
          return log("List of files", file);
        };
      }
      params = {
        path: "/drive/v2/files",
        method: "GET",
        params: {
          q: query
        }
      };
      return this.make_request(params, callback);
    },
    make_request: function(params, callback) {
      params['callback'] = function(data) {
        if (callback != null) {
          callback(data);
        }
        if (window.current_syncing != null) {
          return window.current_syncing.ok();
        }
      };
      if (window.current_syncing != null) {
        window.current_syncing.wait();
      }
      return gapi.client.request(params);
    },
    get_current_user: function(callback) {
      var params, process,
        _this = this;
      log("get current user");
      process = function(file) {
        var user;
        log("About called ", file);
        user = {};
        user.name = file["user"].displayName;
        user.id = file["user"].permissionId;
        if (file["user"].picture != null) {
          user.pic = file["user"].picture.url;
        }
        if (callback != null) {
          return callback(user);
        }
      };
      params = {
        path: "/drive/v2/about",
        method: "GET"
      };
      return this.make_request(params, process);
    },
    add_share_user: function(email, callback) {
      var app_folder_id, params, process,
        _this = this;
      log("&&& add share user");
      process = function(person) {
        var p;
        log("Add Share user Complete ", person);
        p = {
          id: person.id,
          name: person.name,
          role: person.role
        };
        if (person.photoLink != null) {
          p["pic"] = person.photoLink;
        }
        if (callback != null) {
          return callback(p);
        }
      };
      app_folder_id = window.folder[Nimbus.Auth.app_name].id;
      params = {
        path: "/drive/v2/files/" + app_folder_id + "/permissions",
        method: "POST",
        params: {
          fileId: app_folder_id
        },
        body: {
          role: "writer",
          type: "user",
          value: email
        }
      };
      return this.make_request(params, process);
    },
    add_share_user_real: function(email, callback,file_id) {
      var params, process,
        _this = this;
      log("&&& add share user");
      fid = file_id ? file_id : window.c_file.id
      process = function(person) {
        var p;
        log("Add Share user Complete ", person);
        p = {
          id: person.id,
          name: person.name,
          role: person.role
        };
        if (person.photoLink != null) {
          p["pic"] = person.photoLink;
        }
        if (callback != null) {
          return callback(p);
        }
      };
      params = {
        path: "/drive/v2/files/" + fid + "/permissions",
        method: "POST",
        params: {
          fileId: fid
        },
        body: {
          role: "writer",
          type: "user",
          value: email
        }
      };
      return this.make_request(params, process);
    },
    remove_share_user: function(id, callback) {
      var app_folder_id, params;
      log("&&& remove a user from sharing this app");
      app_folder_id = window.folder[Nimbus.Auth.app_name].id;
      if (!callback) {
        callback = function(file) {
          return log("Permission Removal Complete ", file);
        };
      }
      params = {
        path: "/drive/v2/files/" + app_folder_id + "/permissions/" + id,
        method: "DELETE"
      };
      return this.make_request(params, callback);
    },
    remove_share_user_real: function(id, callback,doc_id) {
      var params;
      log("&&& remove a user from sharing this app");
      if (!callback) {
        callback = function(file) {
          return log("Permission Removal Complete ", file);
        };
      }
      doc_id = doc_id ? doc_id : window.c_file.id;
      params = {
        path: "/drive/v2/files/" + doc_id + "/permissions/" + id,
        method: "DELETE"
      };
      return this.make_request(params, callback);
    },
    get_user_email: function() {
      var access_token, data, xhr;
      if (window.user_email != null) {
        return window.user_email;
      }
      access_token = gapi.auth.getToken().access_token;
      data = null;
      xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            return data = JSON.parse(xhr.responseText);
          } else {
            return log("get user email failed with status " + xhr.status);
          }
        }
      };
      xhr.open("GET", "https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=" + access_token, false);
      xhr.send(null);
      if ((data != null ? data.email : void 0) != null) {
        window.user_email = data.email;
        return data.email;
      }
      return null;
    },
    get_shared_users_real: function(callback) {
      var params, process,
        _this = this;
      log("&&& get shared users");
      process = function(file) {
        var p, perm, permissions, _i, _len, _ref;
        log("Update Complete ", file);
        permissions = [];
        _ref = file.items;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          perm = {
            id: p.id,
            name: p.name,
            role: p.role
          };
          if (p.photoLink != null) {
            perm["pic"] = p.photoLink;
          }
          permissions.push(perm);
        }
        log("permissions", permissions);
        if (callback != null) {
          return callback(permissions);
        }
      };
      params = {
        path: "/drive/v2/files/" + window.c_file.id + "/permissions",
        method: "GET"
      };
      return this.make_request(params, process);
    },
    get_shared_users: function(callback) {
      var app_folder_id, params, process,
        _this = this;
      log("&&& get shared users");
      app_folder_id = window.folder[Nimbus.Auth.app_name].id;
      process = function(file) {
        var p, perm, permissions, _i, _len, _ref;
        log("Update Complete ", file);
        permissions = [];
        _ref = file.items;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          perm = {
            id: p.id,
            name: p.name,
            role: p.role
          };
          if (p.photoLink != null) {
            perm["pic"] = p.photoLink;
          }
          permissions.push(perm);
        }
        log("permissions", permissions);
        if (callback != null) {
          return callback(permissions);
        }
      };
      params = {
        path: "/drive/v2/files/" + app_folder_id + "/permissions",
        method: "GET"
      };
      return this.make_request(params, process);
    },
    get_app_folders: function(callback) {
      log("&&& get app folders");
      return Nimbus.Client.GDrive.getMetadataList("mimeType = 'application/vnd.google-apps.folder' and title = '" + Nimbus.Auth.app_name + "'", function(data) {
        var f, folders, s, spaces, _i, _len;
        log(data);
        folders = data.items;
        spaces = [];
        if (data.items != null) {
          for (_i = 0, _len = folders.length; _i < _len; _i++) {
            f = folders[_i];
            s = {};
            s.id = f.id;
            s.owner = f.ownerNames[0];
            spaces.push(s);
          }
        }
        log(spaces);
        if (callback != null) {
          return callback(spaces);
        }
      });
    },
    switch_to_app_folder: function(id, callback) {
      var _this = this;
      log("###switch to app folder");
      window.folder = {};
      window.folder[Nimbus.Auth.app_name] = {
        "title": Nimbus.Auth.app_name,
        "id": id
      };
      window.current_syncing = new DelayedOp(function() {
        if (callback != null) {
          return callback();
        }
      });
      localStorage["main_folder_id"] = id;
      Nimbus.Client.GDrive.getMetadataList("mimeType = 'application/vnd.google-apps.folder'", function(data) {
        var a, k, v, x, _i, _len, _ref, _results;
        a = data.items;
        log("###rewriting folders", a);
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          x = a[_i];
          log(x);
          if (x.parents.length > 0 && (x.parents[0].id === id)) {
            window.folder[x.title] = x;
          }
        }
        if (Nimbus.dictModel != null) {
          _ref = Nimbus.dictModel;
          _results = [];
          for (k in _ref) {
            v = _ref[k];
            _results.push(v.records = {});
          }
          return _results;
        }
      });
      return window.current_syncing.ready();
    },
    switch_to_app_file_real: function(id, callback) {
      var _this = this;
      window.current_syncing = new DelayedOp(function() {
        if (callback != null) {
          return callback();
        }
      });
      Nimbus.Share.getFile(id, function(data) {
        var k, v, _ref;
        if (!data.id) {
          return;
        }
        window.c_file = data;
        if (Nimbus.dictModel != null) {
          _ref = Nimbus.dictModel;
          for (k in _ref) {
            v = _ref[k];
            v.records = {};
          }
        }
        return gapi.drive.realtime.load(id, onFileLoaded, initializeModel, handleErrors);
      });
      return window.current_syncing.ready();
    },
    build_params: function(obj) {
      var k, params_arr, v;
      params_arr = (function() {
        var _results;
        _results = [];
        for (k in obj) {
          v = obj[k];
          _results.push("" + (encodeURIComponent(k)) + "=" + (encodeURIComponent(v)));
        }
        return _results;
      })();
      return params_arr.join("&");
    },
    extract_params_from_url: function() {
      var m, params, queryString, regex;
      params = {};
      queryString = location.hash.substring(1);
      regex = /([^&=]+)=([^&]*)/g;
      while (m = regex.exec(queryString)) {
        params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
      }
      return params;
    },
    request_access_token: function() {
      var params, params_str, url;
      params = {
        response_type: "token",
        client_id: Nimbus.Auth.key,
        redirect_uri: window.location.origin+window.location.pathname,
        scope: Nimbus.Auth.secret,
        state: "gdrive_get_access_token",
        approval_prompt: "auto"
      };
      params_str = this.build_params(params);
      url = "https://accounts.google.com/o/oauth2/auth?" + params_str;
      return window.open(url, "_self");
    },
    request_validate_token: function(token) {
      var data, xhr;
      xhr = new XMLHttpRequest();
      data = null;
      xhr.onreadystatechange = function() {
        var _ref;
        if (xhr.readyState === 4) {
          if ((_ref = xhr.status) === 200 || _ref === 400) {
            return data = JSON.parse(xhr.responseText);
          } else {
            return log("validate access token failed with status " + xhr.status);
          }
        }
      };
      xhr.open("GET", "https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=" + token, false);
      xhr.send(null);
      return data;
    },
    is_token_validate: function(token) {
      var data, result;
      result = false;
      data = this.request_validate_token(token);
      if (data == null) {
        return false;
      }
      if (!("error" in data) && (data != null ? data.audience : void 0) === Nimbus.Auth.key) {
        result = true;
      }
      return result;
    },
    handle_auth_redirected: function() {
      return typeof history.replaceState === "function" ? history.replaceState("", document.title, window.location.pathname) : void 0;
    },
    is_auth_redirected: function() {
      var params;
      params = this.extract_params_from_url();
      if (params.state === "gdrive_get_access_token" && "token_type" in params && params.token_type === "Bearer") {
        return true;
      }
      return false;
    }
  };

  Nimbus.Client.GDrive.Binary = {
    binary_setup: function() {
      return window.binary = Nimbus.Model.setup("binary", ["name", "path", "copied", "directlink", "sharelink", "expiration", "file_id"]);
    },
    initialize_client: function(run) {
      log("initializing client");
      if ((Nimbus.Auth.key != null) && (Nimbus.Auth.secret != null)) {
        if (!Nimbus.Client.GDrive.check_auth()) {
          return Nimbus.Client.GDrive.authorize(Nimbus.Auth.key, Nimbus.Auth.secret, function() {
            log("GDrive authorized");
            if (run) {
              return run();
            }
          });
        } else {
          if (run) {
            return run();
          }
        }
      } else {
        return log("can't upload file with no GDrive credentials");
      }
    },
    upload_blob: function(blob, name, callback) {
      return Nimbus.Client.GDrive.Binary.initialize_client(function() {
        var reader;
        log("upload new blob");
        reader = new FileReader();
        reader.readAsBinaryString(blob);
        return reader.onload = function() {
          var come_back, content, contentType, new_file, parent;
          content = reader.result;
          contentType = blob.type || 'application/octet-stream';
          parent = window.folder["binary_files"].id;
          new_file = binary.create({
            'name': name
          });
          come_back = function(file) {
            console.log("upload file to cloud");
            console.log(file);
            new_file.copied = true;
            new_file.file_id = file.id;
            new_file.directlink = file.webContentLink;
            new_file.save();
            if (callback != null) {
              return callback(new_file);
            }
          };
          return Nimbus.Client.GDrive.insertFile(content, name, contentType, parent, come_back);
        };
      });
    },
    upload_file: function(file, callback) {
      return Nimbus.Client.GDrive.Binary.initialize_client(function() {
        var reader;
        log("upload new file");
        reader = new FileReader();
        reader.readAsBinaryString(file);
        return reader.onload = function() {
          var come_back, content, contentType, name, new_file, parent;
          name = file.name;
          content = reader.result;
          contentType = file.type || 'application/octet-stream';
          parent = window.folder["binary_files"].id;
          new_file = binary.create({
            'name': name
          });
          come_back = function(file) {
            console.log("upload file to cloud");
            console.log(file);
            new_file.copied = true;
            new_file.file_id = file.id;
            new_file.directlink = file.webContentLink;
            new_file.save();
            if (callback != null) {
              return callback(new_file);
            }
          };
          return Nimbus.Client.GDrive.insertFile(content, name, contentType, parent, come_back);
        };
      });
    },
    read_file: function(binary, callback) {
      return Nimbus.Client.GDrive.Binary.initialize_client(function() {
        var param;
        log("read metadata of a file from the server");
        param = {
          path: "/drive/v2/files/" + binary.file_id
        };
        return Nimbus.Client.GDrive.make_request(param, function(data) {
          console.log(data);
          if (callback) {
            return callback(data);
          }
        });
      });
    },
    share_link: function(binary, callback) {
      return Nimbus.Client.GDrive.Binary.initialize_client(function() {
        log("get the share link");
        if (callback) {
          return callback("");
        }
      });
    },
    direct_link: function(binary, callback) {
      return Nimbus.Client.GDrive.Binary.initialize_client(function() {
        log("get the direct link");
        if (callback) {
          return callback(binary.directlink);
        }
      });
    },
    delete_file: function(binary) {
      return Nimbus.Client.GDrive.Binary.initialize_client(function() {
        log("delete file", binary);
        return Nimbus.Client.GDrive.deleteFile(binary.file_id, function() {
          return binary.destroy();
        });
      });
    }
  };

  window.nimbus_error = [];

  Nimbus.Model.GDrive = {
    cloudcache: {},
    last_hash: "",
    hash: "",
    toCloudStructure: function(object) {
      log("local to cloud structure");
      return JSON.stringify(object);
    },
    fromCloudStructure: function(value) {
      log("changes cloud to local data in the form a dictionary");
      return JSON.parse(value);
    },
    diff_objects: function(previous, current) {
      var diff, f, v;
      diff = {};
      for (f in previous) {
        v = previous[f];
        if (current[f] !== previous[f]) {
          diff[f] = [current[f], previous[f]];
        }
      }
      if ((previous["parent_id"] != null) !== (current["parent_id"] != null)) {
        diff["parent_id"] = ["one of them is null"];
      }
      return diff;
    },
    add_to_cloud: function(object, callback) {
      var parent, parent_name;
      log("add to cloud", object);
      parent_name = object.parent.name;
      parent = window.folder[parent_name].id;
      return Nimbus.Client.GDrive.insertFile(this.toCloudStructure(object), object.id, "text/plain", parent, function(data) {
        log("logging data inserted", data);
        window.currently_syncing = true;
        object.gid = data.id;
        object.time = data.modifiedDate;
        object.synced = true;
        object.save();
        return window.currently_syncing = false;
      });
    },
    delete_from_cloud: function(object_id, callback) {
      log("delete from cloud", object_id);
      return Nimbus.Client.GDrive.getMetadataList("title = '" + object_id + "'", function(data) {
        var id;
        log("data", data);
        if (data.items.length > 0) {
          id = data.items[0].id;
          Nimbus.Client.GDrive.deleteFile(id);
          if (callback != null) {
            return callback();
          }
        } else {
          return log("file to be deleted not there");
        }
      });
    },
    update_to_cloud: function(object, callback) {
      var comeback, parent, parent_name, update_comback,
        _this = this;
      log("updated to cloud", object.name);
      parent_name = object.parent.name;
      parent = window.folder[parent_name].id;
      update_comback = function(data) {
        log("logging data inserted", data);
        window.currently_syncing = true;
        object.time = data.modifiedDate;
        object.save();
        object.synced = true;
        return window.currently_syncing = false;
      };
      comeback = function(data) {
        var id;
        id = data.items[0].id;
        return Nimbus.Client.GDrive.updateFile(_this.toCloudStructure(object), object.id, "text/plain", id, parent, function(data) {
          log("logging data inserted", data);
          window.currently_syncing = true;
          object.time = data.modifiedDate;
          object.save();
          return window.currently_syncing = false;
        });
      };
      if (object.gid != null) {
        return Nimbus.Client.GDrive.updateFile(this.toCloudStructure(object), object.id, "text/plain", object.gid, parent, function(data) {
          log("logging data updated", data);
          window.currently_syncing = true;
          object.time = data.modifiedDate;
          object.save();
          return window.currently_syncing = false;
        });
      } else {
        return Nimbus.Client.GDrive.getMetadataList("title = '" + object.id + "'", comeback);
      }
    },
    add_from_cloud: function(object_id, callback) {
      var process_data,
        _this = this;
      log("add from cloud GDrive", object_id);
      process_data = function(data) {
        var converted, x;
        log("cloud url data", JSON.parse(data));
        window.currently_syncing = true;
        converted = _this.fromCloudStructure(data);
        x = _this.init(converted);
        x.synced = true;
        x.time = _this.cloudcache[object_id].time;
        x.save();
        return window.currently_syncing = false;
      };
      return Nimbus.Client.GDrive.getMetadataList("title = '" + object_id + "'", function(data) {
        var url;
        log("cloud read data", data);
        window.data = data;
        if ((data.items != null) && data.items.length >= 1) {
          url = window.data.items[0].downloadUrl;
          return Nimbus.Client.GDrive.readFile(url, process_data);
        } else {
          return log("This data is not there");
        }
      });
    },
    update_to_local: function(object, callback) {
      var process_data,
        _this = this;
      log("update to local", object);
      process_data = function(data) {
        var converted, x;
        log("cloud url data", JSON.parse(data));
        window.currently_syncing = true;
        converted = _this.fromCloudStructure(data);
        x = _this.find(object.id);
        converted.time = _this.cloudcache[object.id].time;
        x.updateAttributes(converted);
        return window.currently_syncing = false;
      };
      return Nimbus.Client.GDrive.getMetadataList("title = '" + object.id + "'", function(data) {
        var url;
        log("cloud read data", data);
        window.data = data;
        if (data.error != null) {
          window.nimbus_error.push({
            error: data.error,
            object: object
          });
          return console.log("##ERROR writing back to local", data.error, "object: ", object);
        } else {
          if (data.items.length >= 1) {
            url = window.data.items[0].downloadUrl;
            return Nimbus.Client.GDrive.readFile(url, process_data);
          } else {
            return log("This data is not there");
          }
        }
      });
    },
    sync_all: function(cb) {
      var _this = this;
      log("syncs all the data, normally happens at the start of a program or coming back from offline");
      window.current_syncing = new DelayedOp(function() {
        log("call back sync called");
        window.current_syncing = new DelayedOp(function() {
          window.current_syncing = null;
          if (cb != null) {
            return cb();
          }
        });
        _this.sync_model_base_algo();
        return window.current_syncing.ready();
      });
      this.load_all_from_cloud();
      return window.current_syncing.ready();
    },
    load_all_from_cloud: function() {
      var fill_cache, folder_id, object_name,
        _this = this;
      log("loads all the data from the cloud locally");
      this.cloudcache = {};
      object_name = this.name;
      log("object name", object_name);
      if ((window.folder != null) && (window.folder[object_name] != null)) {
        folder_id = window.folder[object_name].id;
        fill_cache = function(data) {
          var x, _i, _len, _ref, _results;
          log("cloud read data", object_name, data);
          window.data = data;
          if (data.items != null) {
            _ref = data.items;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              x = _ref[_i];
              _this.cloudcache[x.title] = {
                id: x.title,
                time: x.modifiedDate
              };
              if (x.labels.trashed) {
                _results.push(console.log("##### this is trashed #####", x));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          } else {
            return log("###ERROR, no return data");
          }
        };
        return Nimbus.Client.GDrive.getMetadataList("'" + folder_id + "' in parents", fill_cache);
      } else {
        return log("############################BIG ERROR no folder there for load from cloud");
      }
    },
    get_delta: function() {
      return log("get the delta for ", this.name, " since last synced");
    },
    extended: function() {
      this.sync(this.proxy(this.real_time_sync));
      return this.fetch(this.proxy(this.loadLocal));
    }
  };

  window.folder = null;

  window.folder_creation = new OneOp();

  window.creating = {};

  window.handle_initialization = new OneOp();

  window.gdrive_initialized = false;

  window.folder_initialize = function(callback) {
    log("&&& folder initialize");
    log("Nimbus.Client.GDrive.check_auth()", Nimbus.Client.GDrive.check_auth(), "Nimbus.Auth.service", Nimbus.Auth.service);
    if (Nimbus.Client.GDrive.check_auth() && Nimbus.Auth.service === 'GDrive') {
      log("this is authenticated and a GDrive app");
      return Nimbus.Client.GDrive.getMetadataList("mimeType = 'application/vnd.google-apps.folder'", function(data) {
        var a, x, _i, _j, _len, _len1;
        log("#data: ", data);
        if (window.folder === null) {
          window.folder = {};
        }
        a = data.items;
        if (localStorage["main_folder_id"] != null) {
          window.folder[Nimbus.Auth.app_name] = {
            "title": Nimbus.Auth.app_name,
            "id": localStorage["main_folder_id"]
          };
        } else {
          for (_i = 0, _len = a.length; _i < _len; _i++) {
            x = a[_i];
            if (x.title === Nimbus.Auth.app_name) {
              window.folder[x.title] = x;
            }
          }
        }
        if (window.folder[Nimbus.Auth.app_name] == null) {
          window.folder = {};
          return Nimbus.Client.GDrive.insertFile("", Nimbus.Auth.app_name, "application/vnd.google-apps.folder", null, function(data) {
            log("folder data", data);
            window.folder[data.title] = data;
            if (callback != null) {
              callback();
            }
            if (window.folder["binary_files"] == null) {
              return Nimbus.Client.GDrive.insertFile("", "binary_files", "application/vnd.google-apps.folder", window.folder[Nimbus.Auth.app_name].id, function(data) {
                log("binary_files folder data", data);
                log("binary ready callback", binary_ready_callback);
                if (window.binary_ready_callback) {
                  return window.binary_ready_callback();
                }
              });
            } else {
              log("binary ready callback", binary_ready_callback);
              if (window.binary_ready_callback) {
                return window.binary_ready_callback();
              }
            }
          });
        } else {
          log("base folder there: ", window.folder[Nimbus.Auth.app_name].id);
          for (_j = 0, _len1 = a.length; _j < _len1; _j++) {
            x = a[_j];
            log(x);
            if (x.parents.length > 0 && (x.parents[0].id === window.folder[Nimbus.Auth.app_name].id)) {
              window.folder[x.title] = x;
            }
          }
          if (callback != null) {
            callback();
          }
          if (window.folder["binary_files"] == null) {
            return Nimbus.Client.GDrive.insertFile("", "binary_files", "application/vnd.google-apps.folder", window.folder[Nimbus.Auth.app_name].id, function(data) {
              log("binary_files folder data", data);
              log("binary ready callback", binary_ready_callback);
              if (window.binary_ready_callback) {
                return window.binary_ready_callback();
              }
            });
          } else {
            log("binary ready callback", binary_ready_callback);
            if (window.binary_ready_callback) {
              return window.binary_ready_callback();
            }
          }
        }
      });
    }
  };

  window.model_initialize = function(model) {
    log("initialized model", model);
    log("#loaded", window.loaded, window.gdrive_initialized);
    if (!Nimbus.loaded || !Nimbus.Client.GDrive.check_auth()) {
      log("initialization called later");
      window.handle_initialization.add_call(function() {
        return window.model_initialize(model);
      });
      return;
    }
    if (window.folder === null) {
      log("window.folder object not present");
      log("#folder creation is running", window.folder_creation.running);
      if (window.creating[model.name] == null) {
        window.creating[model.name] = true;
        if (window.folder_creation.running === false) {
          window.folder_initialize(function() {
            return window.folder_creation.execute_callback();
          });
        }
        return window.folder_creation.add_call(function() {
          log("THE CALLBACK IS CALLED", "model.name exists", window.folder[model.name] != null);
          if (window.folder[model.name] == null) {
            return Nimbus.Client.GDrive.insertFile("", model.name, "application/vnd.google-apps.folder", window.folder[Nimbus.Auth.app_name].id, function(data) {
              return window.folder[data.title] = data;
            });
          }
        });
      }
    } else {
      if (window.folder[model.name] != null) {
        return log("model folder there");
      } else {
        log("creating model folder for", model.name);
        return Nimbus.Client.GDrive.insertFile("", model.name, "application/vnd.google-apps.folder", window.folder[Nimbus.Auth.app_name].id, function(data) {
          return window.folder[data.title] = data;
        });
      }
    }
  };

  Nimbus.Auth.GDrive = {
    get_token_from_code: function(code) {
      var data, xhr,
        _this = this;
      xhr = new XMLHttpRequest();
      data = "code=" + code + "&client_id=" + this.key + "&client_secret=" + this.client_secret + "&grant_type=authorization_code&redirect_uri=urn%3Aietf%3Awg%3Aoauth%3A2.0%3Aoob";
      window.data = data;
      xhr.open("POST", "https://accounts.google.com/o/oauth2/token");
      xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      xhr.onreadystatechange = function(status, response) {
        if (xhr.readyState === 4) {
          try {
            console.log("xhr", xhr);
            console.log("TOKEN RETRIEVAL LOGGED");
            var result = JSON.parse(xhr.response);
            if (result["error"]) {
              console.log('erro');
            }else{
               window.plugins.childBrowser.close();
               localStorage["phonegap_token"] = JSON.stringify(result);
               localStorage["state"] = "Working";

               gapi.auth.setToken(result);

               _this.prepare_gdrive();
               console.log('Token got,ready to take off');
            };
            return console.log("response: "+ xhr.response);
          } catch (_error) {}
          /*
            if xhr.response is "" #token retrieval wasn't successful
              @short_entire_process()
            else #token retrieval has a response, thus successful?              
              window.obj = $.parseJSON( xhr.response)
              
              if window.obj["error"]? #response has an error, was not successful
                @short_entire_process()
              else  
                #1. Set the access token as the current token
                #2. Set the refresh token 
                #3. Set a timer for when the access token is expired
                current_token = Token.first()
                current_token.current_token = window.obj['access_token']
                now = moment().add('seconds', window.obj['expires_in']);
                current_token.expiration = now.toString()
                current_token.save()
                
                callback()
                
                for cb_stored in window.callback_queue
                  cb_stored()
          catch err
            log(err)
          finally
            window.calling_for_token = false
            window.current_syncing.ok() if window.current_syncing? #match the previous call
            window.sync_animation.ok()
          */

        }
      };
      xhr.send(data);
      return window.xhr = xhr;
    },
    authenticate_gdrive: function() {
      var auth_url, ref;
      log("this should bring up a prompt to initialize into GDrive");
      localStorage["d_key"] = this.key;
      localStorage["secret"] = this.secret;
      localStorage["state"] = "Auth";
      if (document.URL.slice(0, 4) === "file" && (typeof cordova !== "undefined" && cordova !== null)) {
        log("Phonegap google login");
        auth_url = "https://accounts.google.com/o/oauth2/auth?response_type=code&client_id=" + this.key +  "&scope=" + encodeURIComponent(this.secret) + "&approval_prompt=auto&redirect_uri=urn:ietf:wg:oauth:2.0:oob";
        
        window.auth_url = auth_url;
        cb = window.plugins.childBrowser;
        if(cb != null) {
          cb.onLocationChange = function(loc){ locChanged(loc); };
          cb.onClose = function(){onCloseBrowser(); };
          cb.onOpenExternal = function(){onOpenExternal(); }
          var url = auth_url+"###var sendToApp = function(_key, _val) {var iframe = document.createElement('IFRAME');iframe.setAttribute('src', _key + ':##sendToApp##' + _val);document.documentElement.appendChild(iframe);iframe.parentNode.removeChi(iframe);iframe = null;};var log=function(_mssg){sendToApp('ios-log',_mssg);}; var html = document.getElementById('code').value; log(html);";
          console.log(url);

          cb.onJSCallback = function(backStr){
            cb.code = backStr;
            console.log(backStr);
            if(backStr && backStr !== null && backStr!="(null)"){
              cb.close();
              console.log("will get some toaken");
              Nimbus.Auth.get_token_from_code(backStr);
            }
          };
          cb.showWebPage(url);
        }

      } else if (location.protocol === "chrome-extension:") {
        log("chrome extension authorize");
        return this.oauth2_authorize();
      } else {
        return Nimbus.Client.GDrive.request_access_token();
      }
      /*
      gapi.auth.authorize
        client_id: @key
        scope: @secret
        immediate: false
      , (data)-> 
        log "client load handled GDrive"
        log data
      
        localStorage["state"] = "Working"
        Nimbus.Auth.authorized_callback() if Nimbus.Auth.authorized_callback?
        window.handle_initialization.execute_callback() if window.handle_initialization?
      */

    },
    initialize_gdrive: function() {
      var _this = this;
      log("This part should reflect what initialization needs to be done for GDrive auth");
      Nimbus.gdrive_initialized = true;
      if (Nimbus.loaded) {
        if (location.protocol === "chrome-extension:") {
          return this.oauth2_authorize_second_half();
        }else {
          if (Nimbus.Client.GDrive.is_auth_redirected()) {
            Nimbus.Client.GDrive.handle_auth_redirected();
          }
          // @todo check if token has expired
          if (localStorage['phonegap_token']) {
            gapi.auth.setToken(JSON.parse(localStorage['phonegap_token']));
            return _this.prepare_gdrive();
          };
          console.log("GDrive loaded");
          return gapi.auth.authorize({
            client_id: this.key,
            scope: this.secret,
            immediate: true
          }, function(data) {
            log("client load handled GDrive");
            log(data);
            if (data !== null) {
              return _this.prepare_gdrive();
            }
          });
        }
      }
    },
    gdrive_authorized: function() {
      return Nimbus.Client.GDrive.check_auth();
    },
    logout_gdrive: function(callback) {
      var k, v, _ref;
      localStorage.clear();
      gapi.auth.setToken(null);
      if (Nimbus.dictModel != null) {
        _ref = Nimbus.dictModel;
        for (k in _ref) {
          v = _ref[k];
          v.records = {};
        }
      }
      if (this.sync_services != null) {
        Nimbus.Auth.setup(this.sync_services);
      }
      if (callback != null) {
        return callback();
      }
    },
    prepare_gdrive: function() {
      window.binary_ready_callback = function() {
        if (Nimbus.Auth.authorized_callback != null) {
          return Nimbus.Auth.authorized_callback();
        }
      };
      return window.startRealtime(function() {
        log("CURRENT SYNCING CALLBACK");
        return Nimbus.Auth.app_ready_func();
      });
      /*
      window.current_syncing = new DelayedOp =>
        log("CURRENT SYNCING CALLBACK")
        Nimbus.Auth.app_ready_func()
      */

    },
    oauth2_authorize: function() {
      var background, params, url;
      background = chrome.extension.getBackgroundPage();
      background.NimbusAuth2 = (function(background_window) {
        var NimbusAuth2;
        NimbusAuth2 = {
          OAUTH2_REDIRECT_URI: 'http://www.google.com/robots.txt',
          getExtensionId: function() {
            return background_window.chrome.i18n.getMessage("@@extension_id");
          },
          isOauth2AuthorizeRedirected: function(base, state) {
            if (base === this.OAUTH2_REDIRECT_URI && state === this.getExtensionId()) {
              return true;
            }
            return false;
          },
          parseParamsString: function(queryString) {
            var m, params, regex;
            params = {};
            regex = /([^&=]+)=([^&]*)/g;
            while (m = regex.exec(queryString)) {
              params[background_window.decodeURIComponent(m[1])] = background_window.decodeURIComponent(m[2]);
            }
            return params;
          },
          parseRedirectedURL: function(url) {
            var base_url, hash, params, _ref;
            _ref = url.split('#'), base_url = _ref[0], hash = _ref[1];
            params = this.parseParamsString(hash);
            return {
              base_url: base_url,
              params: params
            };
          },
          generateRedirectListener: function() {
            var listener,
              _this = this;
            listener = function(tab_id, change_info, tab) {
              var entension_windows, url_obj, w, _i, _len;
              if (change_info.status !== 'loading') {
                return;
              }
              url_obj = _this.parseRedirectedURL(tab.url);
              if (_this.isOauth2AuthorizeRedirected(url_obj.base_url, url_obj.params.state)) {
                background_window.chrome.tabs.onUpdated.removeListener(listener);
                background_window.chrome.tabs.remove(tab_id);
                url_obj['saved_time'] = (new background_window.Date()).getTime();
                background_window.localStorage['_nimbusGDriveAuthObj'] = background_window.JSON.stringify(url_obj);
                if (_this.isPackagedApp()) {
                  background_window.console.log("in packaged app");
                  entension_windows = background_window.chrome.extension.getViews({
                    type: 'tab'
                  });
                  for (_i = 0, _len = entension_windows.length; _i < _len; _i++) {
                    w = entension_windows[_i];
                    if (w.Nimbus.Auth.GDrive.oauth_status_flag === 'ongoing') {
                      w.Nimbus.Auth.GDrive.oauth2_authorize_second_half();
                    }
                  }
                } else if (_this.isBrowserAction()) {
                  background_window.console.log("in browser action");
                }
                return null;
              }
            };
            return listener;
          },
          installRedirectedListener: function() {
            return background_window.chrome.tabs.onUpdated.addListener(this.generateRedirectListener());
          },
          isBrowserAction: function() {
            return 'browser_action' in background_window.chrome.runtime.getManifest();
          },
          isPackagedApp: function() {
            return 'app' in background_window.chrome.runtime.getManifest();
          }
        };
        return NimbusAuth2;
      })(background);
      Nimbus.Auth.GDrive.oauth_status_flag = 'ongoing';
      background.NimbusAuth2.installRedirectedListener();
      url = "https://accounts.google.com/o/oauth2/auth?";
      params = {
        client_id: this.key,
        scope: this.secret,
        redirect_uri: this.OAUTH2_REDIRECT_URI,
        state: this.getExtensionId(),
        response_type: 'token',
        approval_prompt: 'auto'
      };
      url += this.buildParamsString(params);
      return chrome.tabs.create({
        url: url
      });
    },
    oauth2_authorize_second_half: function() {
      var issued_at, save_token, token, url_obj;
      if (localStorage._nimbusGDriveAuthObj != null) {
        url_obj = JSON.parse(localStorage['_nimbusGDriveAuthObj']);
        if ('error' in url_obj) {
          throw new Error("authorization failed with error: " + url_obj.error);
        }
        save_token = url_obj.params;
        issued_at = Math.round(url_obj.saved_time / 1000);
        save_token.client_id = this.key;
        save_token.scope = this.secret;
        save_token.response_type = 'token';
        save_token.issued_at = issued_at.toString();
        save_token.expires_at = (issued_at + parseInt(save_token.expires_in)).toString();
        save_token.state = '';
        delete localStorage['_nimbusGDriveAuthObj'];
        localStorage['_chromeExtensionAuth2Token'] = JSON.stringify(save_token);
      }
      if (localStorage['_chromeExtensionAuth2Token']) {
        token = JSON.parse(localStorage['_chromeExtensionAuth2Token']);
        gapi.auth.setToken(token);
        Nimbus.Auth.GDrive.oauth_status_flag = 'finish';
        return this.prepare_gdrive();
      }
    },
    OAUTH2_REDIRECT_URI: 'http://www.google.com/robots.txt',
    getExtensionId: function() {
      return chrome.i18n.getMessage("@@extension_id");
    },
    buildParamsString: function(obj) {
      var k, params_arr, v;
      params_arr = (function() {
        var _results;
        _results = [];
        for (k in obj) {
          v = obj[k];
          _results.push("" + (encodeURIComponent(k)) + "=" + (encodeURIComponent(v)));
        }
        return _results;
      })();
      return params_arr.join("&");
    },
    getLocalOauth2Token: function(token) {
      if (Nimbus.Auth.GDrive._cacheToken != null) {
        return Nimbus.Auth.GDrive._cacheToken;
      }
      if (localStorage._chromeExtensionAuth2Token != null) {
        token = JSON.parse(localStorage._chromeExtensionAuth2Token);
        Nimbus.Auth.GDrive._cacheToken = token;
        return token;
      } else {
        return null;
      }
    },
    isTokenExpires: function(token) {
      var expires_at, now;
      if ((token != null ? token.expires_at : void 0) != null) {
        expires_at = parseInt(token.expires_at);
        now = (new Date()).getTime();
        if ((expires_at * 1000) > now) {
          return true;
        } else {
          return false;
        }
      }
      return true;
    }
  };

  Nimbus.Auth.Multi = {
    authenticate_service: function(service) {
      var isArray, key, user_email_scope, val, x, _ref;
      log("authenticate a single service", service);
      isArray = Array.isArray || function(value) {
        return {}.toString.call(value) === '[object Array]';
      };
      if ((this.sync_services != null) && (this.sync_services[service] != null)) {
        x = this.sync_services[service];
        if (service === "Dropbox") {
          Nimbus.Auth.setup(service, x.key, x.secret, x.app_name);
        }
        if (service === "GDrive") {
          user_email_scope = 'https://www.googleapis.com/auth/userinfo.email';
          if (isArray(x.scope)) {
            if (__indexOf.call(x.scope, user_email_scope) < 0) {
              x.scope.push(user_email_scope);
            }
          } else {
            x.scope = [x.scope, user_email_scope];
          }
          x.scope = x.scope.join(" ");
          if (x.client_secret != null) {
            Nimbus.Auth.setup(service, x.key, x.scope, x.app_name, x.client_secret);
          } else {
            Nimbus.Auth.setup(service, x.key, x.scope, x.app_name);
          }
        }
        _ref = Nimbus.dictModel;
        for (key in _ref) {
          val = _ref[key];
          Nimbus.Model.service_setup(val);
        }
        Nimbus.Auth.initialize();
        return Nimbus.Auth.authorize();
      }
    },
    initialize_service: function() {
      return log("initializing service");
    }
  };

  Nimbus.Auth.reinitialize();

  Nimbus.backbone_store = function(name, model) {
    var k, k_arr, m, nimbus_model, store, v, _ref;
    log("Model on creation", model);
    this.name = name;
    m = new model;
    k_arr = [];
    _ref = m.attributes;
    for (k in _ref) {
      v = _ref[k];
      k_arr.push(k);
    }
    nimbus_model = Nimbus.Model.setup(name, k_arr);
    store = nimbus_model;
    this.data = (nimbus_model.all()) || {};
    return store;
  };

  Nimbus.backbone_sync = function(method, model, options) {
    var a, resp, s, store;
    resp = void 0;
    store = model.nimbus || model.collection.nimbus;
    window.model = model;
    switch (method) {
      case "read":
        if (model.id) {
          resp = store.find(model);
        } else {
          store.sync_all(function() {
            resp = store.all();
            return options.success(resp);
          });
          return;
        }
        break;
      case "create":
        console.log("create called");
        a = store.init(model.attributes);
        a.id = model.id;
        a.save();
        resp = a;
        break;
      case "update":
        s = store.find(model.id);
        s.updateAttributes(model.attributes);
        s.save();
        resp = s;
        break;
      case "delete":
        console.log("deletion find", store.find(model.id));
        resp = store.find(model.id).destroy();
    }
    if (resp) {
      return options.success(resp);
    } else {
      return options.error("Record not found");
    }
  };

  Nimbus.angularService = function() {
    var all_models, makeWatcher, setup;
    all_models = {};
    setup = function(name, attrs, sync_callback) {
      var store;
      store = Nimbus.Model.setup(name, attrs);
      store.sync_all(sync_callback);
      all_models['name'] = store;
      return store;
    };
    makeWatcher = function(name) {
      return function() {
        return localStorage[name];
      };
    };
    return {
      'setup': setup,
      'makeWatcher': makeWatcher
    };
  };

  "use strict";

  global = this;

  if (global.Base64) {
    return;
  }

  version = "2.1.2";

  buffer = void 0;

  if (typeof module !== "undefined" && module.exports) {
    buffer = require("buffer").Buffer;
  }

  b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  b64tab = function(bin) {
    var i, l, t;
    t = {};
    i = 0;
    l = bin.length;
    while (i < l) {
      t[bin.charAt(i)] = i;
      i++;
    }
    return t;
  };

  b64chars;

  fromCharCode = String.fromCharCode;

  cb_utob = function(c) {
    var cc;
    if (c.length < 2) {
      cc = c.charCodeAt(0);
      if (cc < 0x80) {
        return c;
      } else {
        if (cc < 0x800) {
          return fromCharCode(0xc0 | (cc >>> 6)) + fromCharCode(0x80 | (cc & 0x3f));
        } else {
          return fromCharCode(0xe0 | ((cc >>> 12) & 0x0f)) + fromCharCode(0x80 | ((cc >>> 6) & 0x3f)) + fromCharCode(0x80 | (cc & 0x3f));
        }
      }
    } else {
      cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);
      return fromCharCode(0xf0 | ((cc >>> 18) & 0x07)) + fromCharCode(0x80 | ((cc >>> 12) & 0x3f)) + fromCharCode(0x80 | ((cc >>> 6) & 0x3f)) + fromCharCode(0x80 | (cc & 0x3f));
    }
  };

  re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;

  utob = function(u) {
    return u.replace(re_utob, cb_utob);
  };

  cb_encode = function(ccc) {
    var chars, ord, padlen;
    padlen = [0, 2, 1][ccc.length % 3];
    ord = ccc.charCodeAt(0) << 16 | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8) | (ccc.length > 2 ? ccc.charCodeAt(2) : 0);
    chars = [b64chars.charAt(ord >>> 18), b64chars.charAt((ord >>> 12) & 63), (padlen >= 2 ? "=" : b64chars.charAt((ord >>> 6) & 63)), (padlen >= 1 ? "=" : b64chars.charAt(ord & 63))];
    return chars.join("");
  };

  btoa = global.btoa || function(b) {
    return b.replace(/[\s\S]{1,3}/g, cb_encode);
  };

  _encode = (buffer ? function(u) {
    return (new buffer(u)).toString("base64");
  } : function(u) {
    return btoa(utob(u));
  });

  encode = function(u, urisafe) {
    if (!urisafe) {
      return _encode(u);
    } else {
      return _encode(u).replace(/[+\/]/g, function(m0) {
        if (m0 === "+") {
          return "-";
        } else {
          return "_";
        }
      }).replace(RegExp("=", "g"), "");
    }
  };

  encodeURI = function(u) {
    return encode(u, true);
  };

  re_btou = re_btou = new RegExp(['[\xC0-\xDF][\x80-\xBF]', '[\xE0-\xEF][\x80-\xBF]{2}', '[\xF0-\xF7][\x80-\xBF]{3}'].join('|'), 'g');

  cb_btou = function(cccc) {
    var cp, offset;
    switch (cccc.length) {
      case 4:
        cp = ((0x07 & cccc.charCodeAt(0)) << 18) | ((0x3f & cccc.charCodeAt(1)) << 12) | ((0x3f & cccc.charCodeAt(2)) << 6) | (0x3f & cccc.charCodeAt(3));
        offset = cp - 0x10000;
        return fromCharCode((offset >>> 10) + 0xD800) + fromCharCode((offset & 0x3FF) + 0xDC00);
      case 3:
        return fromCharCode(((0x0f & cccc.charCodeAt(0)) << 12) | ((0x3f & cccc.charCodeAt(1)) << 6) | (0x3f & cccc.charCodeAt(2)));
      default:
        return fromCharCode(((0x1f & cccc.charCodeAt(0)) << 6) | (0x3f & cccc.charCodeAt(1)));
    }
  };

  btou = function(b) {
    return b.replace(re_btou, cb_btou);
  };

  cb_decode = function(cccc) {
    var chars, len, n, padlen;
    len = cccc.length;
    padlen = len % 4;
    n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0);
    chars = [fromCharCode(n >>> 16), fromCharCode((n >>> 8) & 0xff), fromCharCode(n & 0xff)];
    chars.length -= [0, 0, 2, 1][padlen];
    return chars.join("");
  };

  atob = global.atob || function(a) {
    return a.replace(/[\s\S]{1,4}/g, cb_decode);
  };

  _decode = (buffer ? function(a) {
    return (new buffer(a, "base64")).toString();
  } : function(a) {
    return btou(atob(a));
  });

  decode = function(a) {
    return _decode(a.replace(/[-_]/g, function(m0) {
      if (m0 === "-") {
        return "+";
      } else {
        return "/";
      }
    }).replace(/[^A-Za-z0-9\+\/]/g, ""));
  };

  global.Base64 = {
    VERSION: version,
    atob: atob,
    btoa: btoa,
    fromBase64: decode,
    toBase64: encode,
    utob: utob,
    encode: encode,
    encodeURI: encodeURI,
    btou: btou,
    decode: decode
  };

  if (typeof Object.defineProperty === "function") {
    noEnum = function(v) {
      return {
        value: v,
        enumerable: false,
        writable: true,
        configurable: true
      };
    };
    global.Base64.extendString = function() {
      Object.defineProperty(String.prototype, "fromBase64", noEnum(function() {
        return decode(this);
      }));
      Object.defineProperty(String.prototype, "toBase64", noEnum(function(urisafe) {
        return encode(this, urisafe);
      }));
      return Object.defineProperty(String.prototype, "toBase64URI", noEnum(function() {
        return encode(this, true);
      }));
    };
  }

  mixpanel_token = "57da9d172e8c2000bca77d9ebb935752";

  Nimbus.track = {
    send_people_request: function(x) {
      var encoded, xhr,
        _this = this;
      xhr = new XMLHttpRequest();
      log(JSON.stringify(x));
      encoded = Base64.encode(JSON.stringify(x));
      window.data = "data=" + encoded;
      xhr.open("POST", "http://api.mixpanel.com/engage");
      xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      xhr.onreadystatechange = function(status, response) {
        if (xhr.readyState === 4) {
          try {
            log("xhr", xhr);
            log("mixpanel response done");
            return log("response: ", xhr.response);
          } catch (_error) {}
        }
      };
      xhr.send(data);
      return window.xhr = xhr;
    },
    registered_user: function() {
      var email;
      log("registered user");
      if (Nimbus.Auth.service === "Dropbox") {
        Nimbus.Client.Dropbox.getAccountInfo(function(info) {
          var email, first, last, n, x, _ref;
          n = info.display_name;
          _ref = n.split(" "), first = _ref[0], last = _ref[1];
          email = "";
          if (info.email != null) {
            email = info.email;
          }
          x = {
            $set: {
              $first_name: first,
              $last_name: last,
              $app: Nimbus.Auth.app_name,
              $service: Nimbus.Auth.service,
              $email: email,
              $url: window.location.href
            },
            $token: mixpanel_token,
            $distinct_id: email
          };
          log(x);
          return Nimbus.track.send_people_request(x);
        });
      }
      if (Nimbus.Auth.service === "GDrive") {
        email = Nimbus.Client.GDrive.get_user_email();
        return Nimbus.Client.GDrive.get_current_user(function(info) {
          var first, last, n, x, _ref;
          n = info.name;
          _ref = n.split(" "), first = _ref[0], last = _ref[1];
          x = {
            $set: {
              $first_name: first,
              $last_name: last,
              $app: Nimbus.Auth.app_name,
              $service: Nimbus.Auth.service,
              $email: email,
              $url: window.location.href
            },
            $token: mixpanel_token,
            $distinct_id: email
          };
          log(x);
          return Nimbus.track.send_people_request(x);
        });
      }
    },
    report_storage_stat: function() {
      var last_reported_date, now;
      log("report storage stat");
      now = new Date();
      if (localStorage["last_reported_date"] != null) {
        last_reported_date = localStorage["last_reported_date"];
      }
      if (last_reported_date) {
        if (now - last_reported_date > 86400000) {
          log("start sending data");
        }
        return localStorage["last_reported_date"] = now;
      } else {
        return log("start sending data");
      }
    }
  };

  this.Nimbus = Nimbus;

}).call(this);
